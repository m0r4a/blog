


[{"content":"Tex tt asdf\n","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_6/","section":"Projects","summary":"Placeholder","title":"Chapter 6: Multiarea OSPF","type":"projects"},{"content":" set # A set is a collection of unique elements. It is an unordered collection of items. Sets are used to store multiple items in a single variable. It is a collection data type in Python.\nDoumentation\nExample without using set # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] houses = [] for student in students: if student[\u0026#34;house\u0026#34;] not in houses: houses.append(student[\u0026#34;house\u0026#34;]) for house in sorted(houses): print(house) Example without re-inveting the wheel: using set # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] houses = set() for student in students: houses.add(student[\u0026#34;house\u0026#34;]) for house in sorted(houses): print(house) global # The global keyword is used to declare that a variable inside the function is global (outside the function). If you want to change a global variable inside a function, you can use the global keyword to declare which variables are global.\nExample where you use a variable that lives outside the function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code that tries to change a global variable inside a function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) deposit(100) withdraw(50) print(\u0026#34;Balance:\u0026#34;, balance) def deposit(n): balance += n def withdraw(n): balance -= n if __name__ == \u0026#34;__main__\u0026#34;: main() The result is a UnboundLocalError because the variable balance is not defined inside the function deposit.\nApparently is okey to read a global variable inside a function, but if you want to change it, you need to use the global keyword.\nExample of code that changes a global variable inside a function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) deposit(100) withdraw(50) print(\u0026#34;Balance:\u0026#34;, balance) def deposit(n): global balance balance += n def withdraw(n): global balance balance -= n if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code with OOP # class Account: def __init__(self): self._balance = 0 @property def balance(self): return self._balance def deposit(self, n): self._balance += n def withdraw(self, n): self._balance -= n def main(): account = Account() print(\u0026#34;Balance:\u0026#34;, account.balance) account.deposit(100) account.withdraw(50) print(\u0026#34;Balance:\u0026#34;, account.balance) if __name__ == \u0026#34;__main__\u0026#34;: main() Usually using global variables is not a good practice. It is better to use classes and objects.\nNote for myself: the instance variable balance and all the other instance variables by definition can be accessed by all the methods of the class.\nconstants # A constant is a type of variable whose value cannot be changed.\nExample of code with \u0026ldquo;constants\u0026rdquo; # MEOWS = 3 for _ in range(MEOWS): print(\u0026#34;meow\u0026#34;) There\u0026rsquo;s actually no way to define a constant in Python. The convention is to use uppercase letters for the variable name to indicate that it should be treated as a constant.\nConstants in OOP # class Cat: MEOWS = 3 def meow(self): for _ in range(Cat.MEOWS): # or self.MEOWS print(\u0026#34;meow\u0026#34;) cat = Cat() cat.meow() Type Hints, mypy # mypy is a static type checker for Python. It is a tool that can be used to check the types of variables and functions in your code.\nDocumentation\nExample of code where an error is detected by mypy # def meow(n): for _ in range(n): print(\u0026#34;meow\u0026#34;) number = input(\u0026#34;Number: \u0026#34;) meow(number) MyPy will detect the error because the function input returns a string, and the function meow expects an integer.\nExample of code with type hints # def meow(n: int): for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = input(\u0026#34;Number: \u0026#34;) meow(number) The code is still wrong, but now mypy can detect the error much quicker by adding type hints.\nCorrect version of the code # def meow(n: int): for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = int(input(\u0026#34;Number: \u0026#34;)) meow(number) Return type hints: error version # def meow(n: int) -\u0026gt; None: for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows) Return type hints: correct version # def meow(n: int) -\u0026gt; str: return \u0026#34;meow\\n\u0026#34; * n number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows, end=\u0026#34;\u0026#34;) Docstrings # A docstring is a string that is used to document a function, method, or class. It is used to describe what the function does, what parameters it takes, and what it returns.\nThere\u0026rsquo;s a standarized way on how to document your functions, methods, and classes in Python, the PEP (Python Enhancement Proposal) is the PEP 257\nExample of code with a docstring # def meow(n: int) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Meow n times. :param n: Number of times to meow. :type n: int :raise TypeError: If n is not an int. :return: A string of n meows, one per line. :rtype: str \u0026#34;\u0026#34;\u0026#34; return \u0026#34;meow\\n\u0026#34; * n number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows, end=\u0026#34;\u0026#34;) argparse # The argparse module is used to parse command-line arguments in Python. It is a standard module that comes with Python.\nDocumentation\nExample of code with argparse # import argparse parser = argparse.ArgumentParser(description=\u0026#34;Meow like a cat.\u0026#34;) parser.add_argument(\u0026#34;-n\u0026#34;, default=1, help=\u0026#34;number of times to meow\u0026#34;, type=int) args = parser.parse_args() for _ in range(args.n): print(\u0026#34;meow\u0026#34;) Note: if you specify that the argument is a type int, you don\u0026rsquo;t need to convert it to an integer.\nunpacking # Unpacking is the process of extracting values from a collection, such as a list or a tuple, and assigning them to variables.\nA very simple example of unpacking # first, _ = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).split(\u0026#34; \u0026#34;) # Here is the unpacking print(f\u0026#34;hello, {first}\u0026#34;) We used the foo, bar = \u0026quot;foo bar\u0026quot;.split(\u0026quot; \u0026quot;) to unpack the values of the list returned by the split method.\nUnpacking a list # def total(galleons, sickles, knuts): return (galleons * 17 + sickles) * 29 + knuts coins = [100, 50, 25] print(total(*coins), \u0026#34;Knuts\u0026#34;) # Here is the unpacking We used the * operator to unpack the values of the list coins and pass them as arguments to the function total.\nUnpacking a dictionary # def total(galleons, sickles, knuts): return (galleons * 17 + sickles) * 29 + knuts coins = {\u0026#34;galleons\u0026#34;: 100, \u0026#34;sickles\u0026#34;: 50, \u0026#34;knuts\u0026#34;: 25} print(total(**coins), \u0026#34;Knuts\u0026#34;) # Here is the unpacking We used the ** operator to unpack the values of the dictionary coins and pass them as arguments to the function total.\n*args and **kwargs # *args is used to pass a variable number of arguments to a function. **kwargs is used to pass a variable number of keyword arguments to a function. def f_positional(*args, **kwargs): print(\u0026#34;Positional:\u0026#34;, args) # The output of this function is: Positional: (100, 50, 25) f_positional(100, 50, 25) def f_keyword(*args, **kwargs): print(\u0026#34;Keyword:\u0026#34;, kwargs) # The output of this function is: Keyword: {\u0026#39;galleons\u0026#39;: 100, \u0026#39;sickles\u0026#39;: 50, \u0026#39;knuts\u0026#39;: 25} f_keyword(galleons=100, sickles=50, knuts=25) map # The map function is used to apply a function to each item in a list or other iterable.\nmap(function, iterable) Documentation\nExample of code without using map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): uppercased = [] for word in words: uppercased.append(word.upper()) print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code using map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): \u0026#34;\u0026#34;\u0026#34; We use str.upper instead of something.upper() because instead of actually applying the method to the string, we are just passing the method itself to the map function. \u0026#34;\u0026#34;\u0026#34; uppercased = map(str.upper, words) print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() List Comprehensions # List comprehensions are a concise way to create lists in Python. They are used to create a new list by applying an expression to each item in an existing list.\nExample of code using a list comprehension instead of a for loop or map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): uppercased = [word.upper() for word in words] print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() filter # The filter function is used to filter items from a list or other iterable.\nfilter(function, iterable) Documentation\nExample of code without using filter # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] gryffindors = [ student[\u0026#34;name\u0026#34;] for student in students if student[\u0026#34;house\u0026#34;] == \u0026#34;Gryffindor\u0026#34; ] for gryffindor in sorted(gryffindors): print(gryffindor) In the code above, we used a list comprehension with a conditional to filter the students that belong to the house Gryffindor.\nExample of code using filter # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] def is_gryffindor(s): return s[\u0026#34;house\u0026#34;] == \u0026#34;Gryffindor\u0026#34; gryffindors = filter(is_gryffindor, students) for gryffindor in sorted(gryffindors, key=lambda s: s[\u0026#34;name\u0026#34;]): print(gryffindor[\u0026#34;name\u0026#34;]) Dictionary Comprehensions # Dictionary comprehensions are a concise way to create dictionaries in Python. They are used to create a new dictionary by applying an expression to each item in an existing dictionary.\nExample of code not using a dictionary comprehension # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] gryffindors = [] for student in students: gryffindors.append({\u0026#34;name\u0026#34;: student, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}) print(gryffindors) Example of code using a dictionary comprehension # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] gryffindors = {student: \u0026#34;Gryffindor\u0026#34; for student in students} print(gryffindors) enumerate # The enumerate function is used to add a counter to an iterable.\nenumerate(iterable, start=0) Documentation\nExample of code without using enumerate # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i in range(len(students)): print(i + 1, students[i]) Example of code using enumerate # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i, student in enumerate(students, start=1): print(i + 1, student) Generators, Iterators, yield # A generator is a function that returns an iterator. It generates values using the yield keyword.\nWhat\u0026rsquo;s a generator?\nExample of code that not works due the lack of using a generator # def main(): n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) for i in range(n): print(sheep(i)) def sheep(n): flock = [] for i in range(n): flock.append(\u0026#34;üêë\u0026#34; * i) return flock if __name__ == \u0026#34;__main__\u0026#34;: main() The problem in the code above is that the function sheep first generates all the values and then returns them all at once. This is not efficient because it uses a lot of memory.\nExample of code using a generator # def main(): n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) for i in range(n): print(sheep(i)) def sheep(n): for i in range(n): yield \u0026#34;üêë\u0026#34; * i if __name__ == \u0026#34;__main__\u0026#34;: main() The word yield is used to return a value at the time, that way we don\u0026rsquo;t need to store all the values in memory but just one at a time.\nyeild is returning an iterator, so we can use it in a for loop.\n","date":"12 August 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_9/","section":"Projects","summary":"A set is a collection of unique elements. It is an unordered collection of items. Sets are used to store multiple items in a single variable. It is a collection data type in Python.","title":"Week 9: Et Cetera","type":"projects"},{"content":"","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_5/","section":"Projects","summary":"Placeholder","title":"Chapter 5: Single-Area OSPF","type":"projects"},{"content":" Object-Oriented Programming (OOP) # Object-Oriented Programming (OOP) is a programming paradigm that uses \u0026ldquo;objects\u0026rdquo; to design applications and computer programs. It utilizes several techniques from previously established paradigms, including modularity, polymorphism, and encapsulation. OOP is based on the concept of \u0026ldquo;objects,\u0026rdquo; which can contain data in the form of fields, often known as attributes, and code in the form of procedures, often known as methods.\nTuples # A tuple is a collection of objects that are ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\ndef main(): student = get_student() print(f\u0026#34;{name} from {house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return name, house if __name__ == \u0026#34;__main__\u0026#34;: main() Dictionaries # A dictionary is a little bit more powerful than a list. It is a collection of key-value pairs. Dictionaries are used to store data values in key:value pairs.\ndef main(): student = get_student() if student[\u0026#34;name\u0026#34;] == \u0026#34;Padma\u0026#34;: student[\u0026#34;house\u0026#34;] = \u0026#34;Ravenclaw\u0026#34; print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} from {student[\u0026#39;house\u0026#39;]}\u0026#34;) def get_student(): return student = { \u0026#34;name\u0026#34;: input(\u0026#34;Name: \u0026#34;), \u0026#34;house\u0026#34;: input(\u0026#34;House: \u0026#34;) } if __name__ == \u0026#34;__main__\u0026#34;: main() Classes and Objects # A class is a blueprint or a mold for creating objects.\nA class is a user-defined blueprint or prototype from which objects are created.\nAn object is an instance of a class that has attributes and methods.\nDocumentation\nSimple use of a class # class Student: ... def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): student = Student() student.name = input(\u0026#34;Name: \u0026#34;) student.house = input(\u0026#34;House: \u0026#34;) return student if __name__ == \u0026#34;__main__\u0026#34;: main() Instance Methods # Table of methods # Method Description __init__() Constructor method, called when a new instance is created. __del__() Destructor method, called when an instance is about to be destroyed. __repr__() Returns an official string representation of the instance, useful for debugging. __str__() Returns a readable string representation, used by print(). __call__() Allows an instance to be called as a function. __eq__() Defines behavior for the equality operator ==. __ne__() Defines behavior for the inequality operator !=. __lt__() Defines behavior for the less-than operator \u0026lt;. __le__() Defines behavior for the less-than-or-equal-to operator \u0026lt;=. __gt__() Defines behavior for the greater-than operator \u0026gt;. __ge__() Defines behavior for the greater-than-or-equal-to operator \u0026gt;=. __len__() Defines behavior for the built-in len() function. __getitem__() Defines behavior for indexing obj[key]. __setitem__() Defines behavior for assigning to indexed elements obj[key] = value. __delitem__() Defines behavior for deleting indexed elements del obj[key]. __iter__() Defines behavior for the iterator protocol. __next__() Defines behavior for retrieving the next item from an iterator. __contains__() Defines behavior for the membership test operators in and not in. __enter__() Defines behavior for entering a context (used with with statement). __exit__() Defines behavior for exiting a context (used with with statement), handles exceptions. __getattr__() Defines behavior for accessing an attribute that does not exist. __setattr__() Defines behavior for setting an attribute\u0026rsquo;s value. __delattr__() Defines behavior for deleting an attribute. __hash__() Defines behavior for the built-in hash() function. __eq__() Defines behavior for the equality operator ==. __ne__() Defines behavior for the inequality operator !=. The Constructor Method: __init__ # The __init__ method is a special method in Python classes that is called when a new instance of the class is created. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() The String Method: __str__ # The __str__ method is called by the str() built-in function and by the print() function to compute the \u0026ldquo;informal\u0026rdquo; or nicely printable string representation of an object. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Custom Methods # class Student: def __init__(self, name, house, patronus): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house self.patronus = patronus def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def charm(self): match self.patronus: case \u0026#34;Stag\u0026#34;: return \u0026#34;üê¥\u0026#34; case \u0026#34;Otter\u0026#34;: return \u0026#34;ü¶¶\u0026#34; case \u0026#34;Jack Russell Terrier\u0026#34;: return \u0026#34;üê∂\u0026#34; case _: return \u0026#34;ü¶Ñ\u0026#34; def main(): student = get_student() print(\u0026#34;Expecto Patronum!\u0026#34;) print(sudent.charm()) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) patronus = input(\u0026#34;Patronus: \u0026#34;) return Student(name, house, patronus) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Properties, Getters, and Setters # Properties are a special kind of attribute that can be accessed like an attribute, but are computed like a method. @property is a decorator that allows you to define a method that can be accessed like an attribute. Getters are methods that allow you to access the value of a property. Setters are methods that allow you to change the value of a property. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; # Getter \u0026#39;\u0026#39;\u0026#39; This is the getter method. This is the \u0026#34;function\u0026#34; that will be called when you try to get the value of the property. like this: print(student.house) \u0026#39;\u0026#39;\u0026#39; @property def house(self): return self._house # Setter \u0026#39;\u0026#39;\u0026#39; This is the setter method. This is the \u0026#34;function\u0026#34; that will be called when you try to set the value of the property. like this: student.house = \u0026#34;Gryffindor\u0026#34; \u0026#39;\u0026#39;\u0026#39; @house.setter def house(self, house): if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self._house = house def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; print(student) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Types and Classes # All this time int was a class: class int(x, base=10). The str has been a class all along: class str(object=''). All the time we used str.lower() we have been taking an object of class str and calling the method lower on it. str.strip([chars]) is the same thing, a method of the str class. list is a class, everytime we created a list we were creating an object of the class list: class list([iterable]). list.append(x) is a method of the list class. dict is a class, everytime we created a dictionary we were creating an object of the class dict: class dict(**kwarg). A small example # print(type(50)) print(type(\u0026#34;Hello, World!\u0026#34;)) print(type([])) print(type({})) Output:\n\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; Class methods # Sometimes is not really necessary to associate a function with object of a class but rather with the class itself.\nSometimes you want that the class have certain behaivor or certain functionality that is not related to the object itself but rather to the class. That means that no matter how is the object created, the class will have that functionality.\nFor that he got another decorator called @classmethod, we use this decorator to define a method that is associated with the class rather than the object.\nSorting hat example # In this example we\u0026rsquo;re gonna implement a sorting hat that will assign a house to a student.\nimport random class Hat: def __init__(self): self.houses = [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;] def sort(self, name): print(name, \u0026#34;is in\u0026#34;, random.choice(self.houses)) hat = Hat() hat.sort(\u0026#34;Harry\u0026#34;) Class method example # The code of above works but it\u0026rsquo;s not really necessary to create an object of the class Hat to sort a student.\nAnd it has a feature/bug, you can create more than one hat, and that\u0026rsquo;s not a functionality that we want. We could do something like this:\nhat1 = Hat() hat2 = Hat() hat3 = Hat() In the world of harry potter the sorting hat is not an object that you can create, it\u0026rsquo;s just one and only one hat that you put on the head of the student and it will sort the student.\nWe have been using instance methods: writing functions inside of classes that are automatically passed a reference to self, the current object, but sometimes you don\u0026rsquo;t need that, sometimes it suffices to just know what the class is and assume that might not even be an object of that class.\nSo in this case we can use a class really as a container for data and/or functions that is somehow conceptually related to the class but not necessarily to the object. Here is where @classmethod comes in.\nimport random class Hat: # This is a list of houses that is shared by all the instances of the class houses = [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;] @classmethod def sort(cls, name): # We dont reference self, we reference cls now which is the class itself print(name, \u0026#34;is in\u0026#34;, random.choice(cls.houses)) Hat.sort(\u0026#34;Harry\u0026#34;) Class method example 2: improving old code # This is the first version of students.py: # class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; # Getter \u0026#39;\u0026#39;\u0026#39; This is the getter method. This is the \u0026#34;function\u0026#34; that will be called when you try to get the value of the property. like this: print(student.house) \u0026#39;\u0026#39;\u0026#39; @property def house(self): return self._house # Setter \u0026#39;\u0026#39;\u0026#39; This is the setter method. This is the \u0026#34;function\u0026#34; that will be called when you try to set the value of the property. like this: student.house = \u0026#34;Gryffindor\u0026#34; \u0026#39;\u0026#39;\u0026#39; @house.setter def house(self, house): if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self._house = house def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; print(student) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Let\u0026rsquo;s do some clean up to focus on the important parts: # class Student: def __init__(self, name, house): self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Let\u0026rsquo;s improve the code using class methods # The original code wasn\u0026rsquo;t bad, but might be a little weird in the long run to have a function related to the class as a separate function outside of the class such as get_student().\nSo what we can do is to move that function inside of the class and make it a class method.\nclass Student: def __init__(self, name, house): self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; @classmethod def get(cls): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return cls(name, hosue) def main(): student = Student.get() print(student) if __name__ == \u0026#34;__main__\u0026#34;: main() Satic methods # @staticmethod is a decorator that allows you to define a method that does not operate on the instance of the class or the class itself.\nAnyway this is a rabbit hole that the course will not go down, but it\u0026rsquo;s good to know that it exists.\nInheritance # Turns out, via OOP (Object Oriented Programming), there\u0026rsquo;s an opportunity to design your classes in a heirarchical way , whereby you can have one class \u0026ldquo;inherit\u0026rdquo; from or borrow attributes that is metods or variables from another class if they are all have those in common.\nTryign this concept: wizard.py # class Wizard: def __init__(self, name): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name ... class Student(Wizard): def __init__(self, name, house): super().__init__(name) # Super have the habilitiy to call the constructor of the parent class self.house = house ... class Professor(Wizard): def __init__(self, name, subject): super().__init__(name) self.subject = subject ... wizard = Wizard(\u0026#34;Albus\u0026#34;) student = Student(\u0026#34;Harry\u0026#34;, \u0026#34;Gryffindor\u0026#34;) professor = Professor(\u0026#34;Severus\u0026#34;, \u0026#34;Defense Against the Dark Arts\u0026#34;) Exceptions hierarchy # BaseException +-- KeyboardInterrupt +-- Exception +-- ArithmeticError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- KeyError +-- NameError +-- SyntaxError | +-- IndentationError +-- ValueError Operator Overloading: vault.py # Operator overloading is a specific case of polymorphism, where different operators have different implementations depending on their arguments.\nIn other words, a + doesn\u0026rsquo;t always mean addition, it can mean concatenation if the operands are strings for example.\nDocumentation\n__add__ is a special method that is called when the + operator is used. class Vault: def __init__(self, galleons=0, sickles=0, knuts=0): self.galleons = galleons self.sickles = sickles self.knuts = knuts def __str__(self): return f\u0026#34;{self.galleons} galleons, {self.sickles} sickles, {self.knuts} knuts\u0026#34; def __add__(self, other): galleons = self.galleons + other.galleons sickles = self.sickles + other.sickles knuts = self.knuts + other.knuts return Vault(galleons, sickles, knuts) potter = Vault(100, 50, 25) print(potter) weasley = Vault(25, 50, 100) print(weasley) total = Vault(galleons, sickles, knuts) print(total) ","date":"3 August 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_8/","section":"Projects","summary":"This week outlines the principles of OOP, including classes, objects, and inheritance, emphasizing how these concepts facilitate code organization and reuse.","title":"Week 8: Object-Oriented Programming","type":"projects"},{"content":"Tex tt asdf\n","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_4/","section":"Projects","summary":"Placeholder","title":"Chapter 4: RIP \u0026 EIGRP","type":"projects"},{"content":" Regular Expressions # Know as a regex is just a pattern that we can use to match strings. It is a powerful tool that allows us to search for strings that match a certain pattern.\nValidation with Regular Expressions # email = input(\u0026#34;Whats your email? \u0026#34;).strip() username, domain = email.split(\u0026#34;@\u0026#34;) if username and domain.ends with(\u0026#34;.edu\u0026#34;): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) re Library # This library let us define a pattern that we can use to match strings.\nDocumentation\nre.search(pattern, string, flags=0) import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(\u0026#34;@\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Regular Expressions Patterns # Symbols # Symbol Description . Matches any character except a newline. ^ Matches the start of the string. $ Matches the end of the string. * Matches 0 or more repetitions of the preceding pattern. + Matches 1 or more repetitions of the preceding pattern. ? Matches 0 or 1 repetition of the preceding pattern. {n} Matches exactly n repetitions of the preceding pattern. {n,} Matches n or more repetitions of the preceding pattern. {n,m} Matches between n and m repetitions of the preceding pattern. [] Matches any one of the characters inside the brackets. [^] Matches any character not inside the brackets. ` ` () Groups patterns and captures the matched text. (?:...) Groups patterns without capturing the matched text. \\ Escapes special characters or denotes a special sequence. \\d Matches any digit; equivalent to [0-9]. \\D Matches any non-digit; equivalent to [^0-9]. \\w Matches any word character (alphanumeric plus underscore); equivalent to [a-zA-Z0-9_]. \\W Matches any non-word character; equivalent to [^a-zA-Z0-9_]. \\s Matches any whitespace character (spaces, tabs, newlines). \\S Matches any non-whitespace character. \\b Matches a word boundary. \\B Matches a non-word boundary. Code using Regular Expression Patterns # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;.+@.+\\.edu\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Matching Start and End # ^ Matches the start of the string. $ Matches the end of the string. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^.+@.+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Sets of Characters # [] Matches any one of the characters inside the brackets. [^] Matches any character not inside the brackets. 1. [^@]+ # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^[^@]+@[^@]+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) 2. [a-zA-Z0-9_]+ # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Character Classes # \\d Matches any digit; equivalent to [0-9]. \\D Matches any non-digit; equivalent to [^0-9]. /s Matches any whitespace character (spaces, tabs, newlines). \\S Matches any non-whitespace character. \\w Matches any word character (alphanumeric plus underscore); equivalent to [a-zA-Z0-9_]. \\W Matches any non-word character; equivalent to [^a-zA-Z0-9_]. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^\\w+@\\w+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Flags # re.IGNORECASE Makes the pattern case-insensitive. re.MULTILINE Makes the pattern match the start and end of each line. re.DOTALL Makes the . character match any character, including newlines. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^\\w+@\\w+\\.edu$\u0026#34;, email, re.IGNORECASE): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Groups # A|B Matches either the pattern before or the pattern after the pipe. () Groups patterns and captures the matched text. (?:...) Groups patterns without capturing the matched text. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^(\\w|\\.)+@(\\w+\\.)?\\w+\\.edu$\u0026#34;, email, re.IGNORECASE): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Email Address Validation # This is the regular expression pattern that the browsers uses to validate email addresses.\n^[a-zA-Z0-9.!#$%\u0026amp;\u0026#39;*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ match, fullmatch # re.match(pattern, string, flags=0) Matches the pattern at the start of the string. re.fullmatch(pattern, string, flags=0) Matches the pattern against the whole string. Capturing Groups # When we use () we are creating a capturing group that allows us to extract the matched text. := is the walrus operator that allows us to assign a value to a variable and use it in the same line. import re name = input(\u0026#34;Whats your name? \u0026#34;).strip() if matches := re.search(r\u0026#34;^(.+), *(.+)$\u0026#34;, name): name = matches.group(2) + \u0026#34; \u0026#34; + matches.group(1) print(f\u0026#34;Hello, {name}\u0026#34;) Extracting from Strings # 1. re.sub # .re.sub(pattern, repl, string, count=0, flags=0) Replaces the matched text with the replacement text. import re url = input(\u0026#34;URL: \u0026#34;).strip() username = re.sub(r\u0026#34;^(https?://)?(www\\.)?twitter\\.com/\u0026#34;, \u0026#34;\u0026#34;, url) print(f\u0026#34;Username: {username}\u0026#34;) 2. re.search # re.search(pattern, string, flags=0) Searches for the pattern in the string. import re url = input(\u0026#34;URL: \u0026#34;).strip() if matches := re.search(r\u0026#34;^https?://?(?:www\\.)?twitter\\.com/([a-z0-9_]+)\u0026#34;, url, re.IGNORECASE) print(f\u0026#34;Username: {matches.group(1)}\u0026#34;) Conclusion # There are other other functions\nre.split(pattern, string, maxsplit=0, flags=0) Splits the string at the matches of the pattern. re.findall(pattern, string, flags=0) Finds all the matches of the pattern in the string. ","date":"26 July 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_7/","section":"Projects","summary":"This week explores regular expressions as powerful tools for string matching and validation, detailing how to use them effectively within Python programs.","title":"Week 7: Regular Expressions","type":"projects"},{"content":"text\n","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_3/","section":"Projects","summary":"Placeholder","title":"Chapter 3: Dynamic Routing","type":"projects"},{"content":" File I/O # File I/O (input/output) is a way to read and write data to and from files. This is useful for saving data to a file, or reading data from a file.\nlists # Usually the data is stored in a list but the moment the program is closed, the data is lost. This is where file I/O comes in. It allows you to save the data to a file, and read it back in when the program is run again.\nCode example of storing data in a list # names = [] for _ in range(3): names.append(input(\u0026#34;What\u0026#39;s your name? \u0026#34;)) for name in sorted(names): print(f\u0026#34;hello, {name}\u0026#34;) open # The open function is used to open a file. It takes two arguments, the name of the file, and the mode to open the file in. The mode can be r for read, w for write, or a for append.\nDocumentation\nCode example of opening a file in write mode # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) file = open(\u0026#34;names.txt\u0026#34;, \u0026#34;w\u0026#34;) file.write(name) file.close() Code example of opening a file in append mode # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) file = open(\u0026#34;names.txt\u0026#34;, \u0026#34;a\u0026#34;) file.write(f\u0026#34;{name}\\n\u0026#34;) file.close() with # The with statement is used to open a file and automatically close it when the block is done. This is useful because it ensures that the file is closed, even if an error occurs.\nDocumentation\nCode example of using the with statement # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) with open(\u0026#34;names.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(f\u0026#34;{name}\\n\u0026#34;) Reading from a file # To read from a file, you can use the read method to read the entire file, or the readline method to read one line at a time.\nThe value returned by the read method is a string, while the value returned by the readline method is a list of strings.\nDocumentation\nCode example of reading from a file # with open(\u0026#34;names.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(\u0026#34;hello,\u0026#34;, line.rstrip()) sorted # The sorted function is used to sort a list. It takes a list as an argument, and returns a new list with the elements sorted.\nDocumentation\n1. Code example of sorting a list (straightforward code) # names - [] \u0026#39;\u0026#39;\u0026#39; When you want to open a file in read mode you don\u0026#39;t need to specify the mode because it is the default mode. \u0026#39;\u0026#39;\u0026#39; with open (\u0026#34;names.txt\u0026#34;) as file: for line in file: names.append(line.rstrip()) for name in sorted(names): print(f\u0026#34;hello, {name}\u0026#34;) 2. Code example of sorting a list (tighter code) # with open(\u0026#34;names.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in sorted(file): print(\u0026#34;hello,\u0026#34;, line.rstrip()) Comma-Separated Values (CSV) # Comma-Separated Values (CSV) is a file format used to store tabular data. Each line in the file represents a row in the table, and the values are separated by commas.\nThe csv module in Python can be used to read and write CSV files.\nDocumentation\nCSV file example # Hermione,Gryffindor Harry,Gryffindor Ron,Gryffindor Draco,Slytherin 1. Code example of reading from a CSV file without the csv module # with open(sudents.csv) as file: for line in file: row = line.rstrip().split(\u0026#34;,\u0026#34;) print(f\u0026#34;{row[0]} is in {row[1]}\u0026#34;) 2. Code example of reading from a CSV file without the csv module and using dictionaries # students = [] with open(sudents.csv) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) for student in students: print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) Sort keys # The sorted function can take a key argument to specify a function to use to extract a comparison key from each element in the list.\nDocumentation\nCode example of sorting a list of dictionaries by a key # students = [] with open(\u0026#34;students.csv\u0026#34;) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) def get_name(student): return student[\u0026#34;name\u0026#34;] for student in sorted(students, key=get_name): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) Lambda functions # Lambda functions are small anonymous functions that can have any number of arguments, but only one expression.\nDocumentation\nCode example of using a lambda function # students = [] with open(\u0026#34;students.csv\u0026#34;) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) New CSV file example # Harry,Number Four, Privet Drive Ron,The Burrow Draco,Malfoy Manor CSV Library # The csv module in Python can be used to read and write CSV files. It provides a DictReader class to read CSV files as dictionaries, and a DictWriter class to write dictionaries to CSV files.\nDocumentation\nCode example of reading from a CSV file using the csv module: reader # import csv students = [] with open(\u0026#34;students.csv\u0026#34;) as file: reader = csv.reader(file) for name, home in reader: students.append({\u0026#34;name\u0026#34;: name, \u0026#34;home\u0026#34;: home}) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is from {student[\u0026#39;home\u0026#39;]}\u0026#34;) Code example of reading from a CSV file using the csv module: DictReader # New CSV file example # name,home Harry,Number Four, Privet Drive Ron,The Burrow Draco,Malfoy Manor Code # import csv students = [] with open(\u0026#34;students.csv\u0026#34;) as file: reader = csv.DictReader(file) for row in reader: sudents.append({\u0026#34;name\u0026#34;: row[\u0026#34;name\u0026#34;], \u0026#34;home\u0026#34;: row[\u0026#34;home\u0026#34;]}) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is from {student[\u0026#39;home\u0026#39;]}\u0026#34;) Code example of writing to a CSV file using the csv module: writer # In the CSV file # name,home Code # import csv name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) home = input(\u0026#34;Where\u0026#39;s your home? \u0026#34;) with open(\u0026#34;students.csv\u0026#34;, \u0026#34;a\u0026#34;) as file: writer = csv.writer(file) writer.writerow([name, home]) Code example of writing to a CSV file using the csv module: DictWriter # Code # import csv name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) home = input(\u0026#34;Where\u0026#39;s your home? \u0026#34;) with open(\u0026#34;students.csv\u0026#34;, \u0026#34;a\u0026#34;) as file: writer = csv.DictWriter(file, fieldnames=[\u0026#34;name\u0026#34;, \u0026#34;home\u0026#34;]) writer.writeheader() # This didn\u0026#39;t appear in the video but is necessary to write the header writer.writerow({\u0026#34;name\u0026#34;: name, \u0026#34;home\u0026#34;: home}) Images, PIL library # The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. This library supports many file formats, and provides powerful image processing and graphics capabilities.\nDocumentation\nCode example of creating a simple gif # import sys from PIL import Image images = [] for arg in sys.argv[1:]: image = Image.open(arg) images.append(image) images[0].save( \u0026#34;costumes.gif\u0026#34;, save_all=True, append_images=[images[1]], duration=200, loop=0 ) ","date":"20 July 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_6/","section":"Projects","summary":"This week covers file input/output operations, explaining how to read and write data, manage file formats like CSV, and manipulate data structures such as lists and dictionaries.","title":"Week 6: File I/O","type":"projects"},{"content":"","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_2/","section":"Projects","summary":"Placeholder","title":"Chapter 2: Static Routing","type":"projects"},{"content":" Unit Tests # Is a way to test the code you wrote.\nTesting calculator.py # Calculator.py code # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(\u0026#34;x squared is\u0026#34;, square(x)) def square(n): return n * n if __name__ == \u0026#34;__main__\u0026#34;: main() test_calculator.py code # from calculator import square def main(): test_square() def test_square(): if square(2) != 4: print(\u0026#34;2 squared is not 4\u0026#34;) if square(3) != 9: print(\u0026#34;3 squared is not 9\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() assert # testing this code\ndef main(): test_square() def test_square(): assert square(2) == 4 assert square(3) == 9 if __name__ == \u0026#34;__main__\u0026#34;: main() AssertionError # How to handle an AssertionError\nFirst \u0026ldquo;bad\u0026rdquo; try # testing this code\ndef main(): test_square() def test_square(): try: assert square(2) == 4 except AssertionError: print(\u0026#34;2 squared is not 4\u0026#34;) try: assert square(3) == 9 except AssertionError: print(\u0026#34;3 squared is not 9\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Second \u0026ldquo;bad\u0026rdquo; try with more examples # testing this code\ndef main(): test_square() def test_square(): try: assert square(2) == 4 except AssertionError: print(\u0026#34;2 squared is not 4\u0026#34;) try: assert square(3) == 9 except AssertionError: print(\u0026#34;3 squared is not 9\u0026#34;) try: assert square(-3) == 9 except AssertionError: print(\u0026#34;-3 squared is not 9\u0026#34;) try: assert square(0) == 0 except AssertionError: print(\u0026#34;0 squared is not 0\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() pytest # Installation # $ pip install pytest Documentation # pytest documentation\nSame test with pytest and all the tests in one function # testing this code\nfrom calculator import square def test_square(): assert square(2) == 4 assert square(3) == 9 assert square(-2) == 4 assert square(-3) == 9 assert square(0) == 0 And then run the test with pytest test_calculator.py\n$ pytest test_calculator.py Categories of tests # testing this code\nfrom calculator import square def test_positive(): assert square(2) == 4 assert square(3) == 9 def test_negative(): assert square(-2) == 4 assert square(-3) == 9 def test_zero(): assert square(0) == 0 Testing for exceptions # testing this code\nimport pytest from calculator import square def test_positive(): assert square(2) == 4 assert square(3) == 9 def test_negative(): assert square(-2) == 4 assert square(-3) == 9 def test_zero(): assert square(0) == 0 def test_str(): with pytest.raises(TypeError): square(\u0026#34;cat\u0026#34;) Side Effects and Testing # hello.py code # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) hello(name) def hello(to=\u0026#34;world\u0026#34;): print(f\u0026#34;hello, \u0026#34;, to) if __name__ == \u0026#34;__main__\u0026#34;: main() test_hello.py code # testing this code\nfrom hello import hello def test_arguement(): assert hello(\u0026#34;David\u0026#34;) == \u0026#34;hello, David\u0026#34; The test will fail because the function hello prints the message instead of returning it.\nPrinting the message is a side effect.\nIs a good practice to avoid side effects in functions as much as possible so the function can be tested.\nNew testable version of hello.py # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) print(hello(name)) def hello(to=\u0026#34;world\u0026#34;): return f\u0026#34;hello, {to}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: main() This is a better version because the assert tests are meant to check the return value of the function and not the side effects. test_hello.py code # testing this code\nfrom hello import hello def test_default(): assert hello() == \u0026#34;hello, world\u0026#34; def test_arguement(): for name in [\u0026#34;Hermione\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;]: assert hello(name) == f\u0026#34;hello, {name}\u0026#34; Collections of tests # With a structure like this:\nproject/ hello.py test/ __init__.py test_hello.py test_hello.py code # from hello import hello def test_default(): assert hello() == \u0026#34;hello, world\u0026#34; def test_arguement(): assert hello(\u0026#34;David\u0026#34;) == \u0026#34;hello, David\u0026#34; init.py # Even if it\u0026rsquo;s empty, __init__.py have the effect of telling Python that the directory is not just a module, but a package.\nRunning the tests # $ pytest test ","date":"14 July 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_5/","section":"Projects","summary":"This week highlights the importance of testing in software development, discussing unit tests and the use of frameworks like pytest to ensure code quality and reliability.","title":"Week 5: Unit Tests","type":"projects"},{"content":"Text text\n","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/chapter_1/","section":"Projects","summary":"This is another test post in which I give a really simple and brief python guide","title":"Chapter 1: IP Routing Overview","type":"projects"},{"content":" Libraries # A piece of code that someone else wrote that you can use in your code.\nModules # Is a library that has one or more functions built into it.\nRe-usability code.\nrandom # random is a built-in module in Python. It has a set of functions to generate random numbers.\nDocumentation\nimport # To use a module, you have to import it.\nimport random coin = random.choice([\u0026#34;head\u0026#34;, \u0026#34;tails\u0026#34;]) print(coin) from # Is the keyword to import a specific function from a module.\nfrom random import choice coin = choice([\u0026#34;head\u0026#34;, \u0026#34;tails\u0026#34;]) print(coin) randint, shuffle # randint # import random number = random.randint(1, 10) print(number) shuffle # import random cards = [\u0026#34;jack\u0026#34;, \u0026#34;queen\u0026#34;, \u0026#34;king\u0026#34;] random.shuffle(cards) for card in cards: print(card) statistics # statistics is a built-in module in Python. It has a set of functions to calculate statistics.\nDocumentation\nimport statistics print(statistics.mean([100, 90])) Command-line Arguments, sys # sys module, provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.\nDocumentation\nsys.argv: argument vector, a list of strings representing the arguments. import sys if len(sys.argv) \u0026lt; 2: print(\u0026#34;Too few arguments\u0026#34;) elif len(sys.argv) \u0026gt; 2: print(\u0026#34;Too many arguments\u0026#34;) else: print(\u0026#34;hello, my name is\u0026#34;, sys.argv[1]) sys.exit # Exit from Python.\nimport sys if len(sys.argv) \u0026lt; 2: sys.exit(\u0026#34;Too few arguments\u0026#34;) elif len(sys.argv) \u0026gt; 2: print(\u0026#34;Too many arguments\u0026#34;) print(\u0026#34;hello, my name is\u0026#34;, sys.argv[1]) slices # A slice is a portion of a list.\nimport sys if len(sys.argv) \u0026lt; 2: sys.exit(\u0026#34;Too few arguments\u0026#34;) for arg in sys.argv[1:]: print(\u0026#34;hello, my name is\u0026#34;, arg) Packages, PyPI, pip # Package: is a collection of modules. PyPI: Python Package Index, is a repository of software for the Python programming language. pip: is a package installer for Python. cowsay # Documentation\nInstall # pip install cowsay Usage # import cowsay import sys if len(sys.arg) == 2: cowsay.cow(\u0026#34;hello, \u0026#34; + sys.argv[1]) APIs, requests, JSON # API: Application Programming Interface. requests: is a simple HTTP library for Python. JSON: JavaScript Object Notation, a language-independent data format. Pretty print JSON # import json import requests import sys if len(sys.argv) != 2: sys.exit() response = requests.get(\u0026#34;https://itunes.apple.com/search?entity=song\u0026amp;limit=1\u0026amp;term=\u0026#34; + sys.argv[1]) print(json.dumps(response.json(), indent=2)) Printing the track name from the API # import json import requests import sys if len(sys.argv) != 2: sys.exit() response = requests.get(\u0026#34;https://itunes.apple.com/search?entity=song\u0026amp;limit=50\u0026amp;term=\u0026#34; + sys.argv[1]) o = response.json() for result in o[\u0026#34;results\u0026#34;]: print(result[\u0026#34;trackName\u0026#34;]) Custom Libraries # Create your own library.\nsayings.py # def main(): hello(\u0026#34;world\u0026#34;) goodbye(\u0026#34;world\u0026#34;) def hello(name): print(f\u0026#34;hello, {name}\u0026#34;) def goodbye(name): print(f\u0026#34;goodbye, {name}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() say.py # import sys from sayings import hello if len(sys.argv) == 2: hello(sys.argv[1]) ","date":"13 July 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_4/","section":"Projects","summary":"This week introduces the concept of libraries and modules in Python, explaining how to import and use them, along with mentioning popular libraries for statistical analysis and file handling.","title":"Week 4: Libraries","type":"projects"},{"content":" Exceptions # That means that something went wrong in the program. It is an error that happens during the execution of the program.\nSyntax Error # This is just and introductory example. The error is in the syntax of the code. It is a mistake in the code that the python interpreter can not execute.\nprint(\u0026#34;Hello World) This error is a error that you need to fix, you can\u0026rsquo;t create a code to handle this error.\nValueError # This error happens when you try to convert a string to a number, but the string is not a number.\nx = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(f\u0026#34;x is {x}\u0026#34;) This programs works fine if you input a number, but if you input a string, it will raise a ValueError.\ntry, except # You can handle exceptions with the try and except blocks.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(f\u0026#34;x is {x}\u0026#34;) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) NameError # This error happens when you try to use a variable that is not defined.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) print(f\u0026#34;x is {x}\u0026#34;) else # You can use the else block to run a code if the try block does not raise an exception.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) else: print(f\u0026#34;x is {x}\u0026#34;) Reprompting, break # You can use a while loop to reprompt the user if the input is not valid.\nwhile True: try: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) else: break print(f\u0026#34;x is {x}\u0026#34;) get_int # You can create a function to get an integer from the user.\ndef main(): x = get_int() print(f\u0026#34;x is {x}\u0026#34;) def get_int(): while True: try: return x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) main() pass # You can use the pass statement to do nothing.\ndef main(): x = get_int() print(f\u0026#34;x is {x}\u0026#34;) def get_int(): while True: try: return x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: pass main() Note: In this case I wouln\u0026rsquo;t use the pass argument, I think as a user would be weird to just be asked again and again for the same input.\nfunction arguments # This is a refined version of the get_int function.\ndef main(): x = get_int(\u0026#34;What\u0026#39;s x? \u0026#34;) print(f\u0026#34;x is {x}\u0026#34;) def get_int(prompt): while True: try: return x = int(input(prompt)) except ValueError: pass main() raise # This was just a quick mention of the raise statement.\n","date":"10 July 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_3/","section":"Projects","summary":"This week focuses on error management in Python, detailing different types of exceptions and methods to handle them, ensuring robust and error-free code execution.","title":"Week 3: Exceptions","type":"projects"},{"content":" Loops # The ability of doing something multiple times cat.py # Example of code # print(\u0026#34;meow\u0026#34;) print(\u0026#34;meow\u0026#34;) print(\u0026#34;meow\u0026#34;) Flowchart of the code # while # Is a way to repeat a block of code while a condition is true While using substraction # i = 3 while i != 0: print(\u0026#34;meow\u0026#34;) i = i - 1 Flowchart of the code # While using addition # i = 0 while i \u0026lt; 3: print(\u0026#34;meow\u0026#34;) i = i + 1 Flowchart of the code # for # Is a way to repeat a block of code a number of times For using a list # for i in [0, 1, 2]: print(\u0026#34;meow\u0026#34;) For using range # for i in range(3): print(\u0026#34;meow\u0026#34;) Pythonic way v1 # The _ is a convention to indicate that the variable is not going to be used or is not important for _ in range(3): print(\u0026#34;meow\u0026#34;) Pythonic way v2 # print(\u0026#34;meow\\n\u0026#34; * 3, end=\u0026#34;\u0026#34;) Validating input # Is a way to ensure that the input is correct Example of code # while True: n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) if n \u0026gt; 0: break for _ in range(n): print(\u0026#34;meow\u0026#34;) Exampo of code using a function # def main(): number = get_number() meow(number) def get_number(): while True: n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) if n \u0026gt; 0: return n def meow(n): for _ in range(n): print(\u0026#34;meow\u0026#34;) main() Iteration with Lists # Is a way to iterate over a list Example of code # students = \u0026#34;[Hermione, Harry, Ron]\u0026#34; for student in students: print(student) len # Is a way to get the length of a list Example of code # students = [\u0026#34;Hermione\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i in range(len(students)): print(i + 1, students[i]) Dictionaries # Is a way to store key-value pairs Example of the code in a manual way # students = { \u0026#34;Hermione\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Harry\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Ron\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Draco\u0026#34;: \u0026#34;Slytherin\u0026#34;, } print(students[\u0026#34;Hermione\u0026#34;]) print(students[\u0026#34;Harry\u0026#34;]) print(students[\u0026#34;Ron\u0026#34;]) print(students[\u0026#34;Draco\u0026#34;]) Example of the code using a loop # students = { \u0026#34;Hermione\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Harry\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Ron\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Draco\u0026#34;: \u0026#34;Slytherin\u0026#34;, } for student in students: print(student, students[student], sep=\u0026#34;, \u0026#34;) List of Dictionaries # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Otter\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Stag\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Jack Russell terrier\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;, \u0026#34;patronus\u0026#34;: None}, ] for student in students: print(student[\u0026#34;name\u0026#34;], student[\u0026#34;house\u0026#34;], student[\u0026#34;patronus\u0026#34;], sep=\u0026#34;, \u0026#34;) Nested Loops # Is a way to have a loop inside another loop Example of code v1 # def main(): print_square(3) def print_square(size): # For each row in square for _ in range(size): # For each brick in row for _ in range(size): # Print brick print(\u0026#34;#\u0026#34;, end=\u0026#34;\u0026#34;) print() main() Example of code v2 # def main(): print_square(3) def print_square(size): for i in range(size): for j in range(size): print(\u0026#34;#\u0026#34;, end=\u0026#34;\u0026#34;) print() main() Example of code v3 # def main(): print_square(3) def print_square(size): for _ in range(size): print(\u0026#34;#\u0026#34; * size) main() Example of code v4 # def main(): print_square(3) def print_square(size): for _ in range(size): print_row(size) def print_row(width): print(\u0026#34;#\u0026#34; * width) main() Expected output for all examples # ### ### ### ","date":"9 May 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_2/","section":"Projects","summary":"This week focuses on loops in programming, detailing how to iterate over data structures using for and while loops, and discussing concepts such as nested loops and list iteration.","title":"Week 2: Loops","type":"projects"},{"content":" Conditionals # Ability to ask and answer questions Comparison Operators in Python # Symbol Meaning \u0026gt; Greater than \u0026lt; Less than == Equal to != Not equal to \u0026gt;= Greater than or equal to \u0026lt;= Less than or equal to if # Example of a code using if # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) if x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) if x == y: print(\u0026#34;x is equal to y\u0026#34;) In this example \u0026ldquo;x \u0026lt; y\u0026rdquo; is a boolean expression Flowchart of the code # elif # Example of a code using elif # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) elif x == y: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # else # Example of a code using else # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # or # Example of a code using or # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y or x \u0026gt; y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # Not Equal # Example of a code using not equal # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x != y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # Example of a code using equal # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x == y: print(\u0026#34;x is equal to y\u0026#34;) else: print(\u0026#34;x is not equal to y\u0026#34;) Flowchart of the code # Identation, Colons # Identation is important in Python, if you don\u0026rsquo;t use it, you will get an error\nThe colon is also important, it tells Python that the next line is going to be a block of code\nand # Example of a code using and # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90 and score \u0026lt;= 100: print(\u0026#34;Grade: A\u0026#34;) elif score \u0026gt;= 80 and score \u0026lt; 90: print(\u0026#34;Grade: B\u0026#34;) elif score \u0026gt;= 70 and score \u0026lt; 80: print(\u0026#34;Grade: C\u0026#34;) elif score \u0026gt;= 60 and score \u0026lt; 70: print(\u0026#34;Grade: D\u0026#34;) else: print(\u0026#34;Grade: F\u0026#34;) Chaining Comparison Operators # Example of a code using chaining comparison operators # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90: print(\u0026#34;Grade: A\u0026#34;) elif score \u0026gt;= 80: print(\u0026#34;Grade: B\u0026#34;) elif score \u0026gt;= 70: print(\u0026#34;Grade: C\u0026#34;) elif score \u0026gt;= 60: print(\u0026#34;Grade: D\u0026#34;) else: print(\u0026#34;Grade: F\u0026#34;) Bugs # Example of a code with a bug: using if instead of elif # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90: print(\u0026#34;Grade: A\u0026#34;) if score \u0026gt;= 80: print(\u0026#34;Grade: B\u0026#34;) if score \u0026gt;= 70: print(\u0026#34;Grade: C\u0026#34;) if score \u0026gt;= 60: print(\u0026#34;Grade: D\u0026#34;) Modulo # Some remaining operators # Symbol Meaning + Addition - Subtraction * Multiplication / Division % Modulo (Remainder) Example of a code using modulo # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) if x % 2 == 0: print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) Boolean # Example of a code using boolean # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if is_even(x): print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) def is_even(n): if n % 2 == 0: return True else: return False main() Pythonic Expressions # Example of a code using Pythonic Expressions # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if is_even(x): print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) def is_even(n): return n % 2 == 0 main() match # Example of a code using match # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) match name: case \u0026#34;Harry\u0026#34; | \u0026#34;Herminone\u0026#34; | \u0026#34;Ron\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) case \u0026#34;Draco:\u0026#34;: print(\u0026#34;Slytherin\u0026#34;) case _: print(\u0026#34;Who?\u0026#34;) ","date":"24 April 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_1/","section":"Projects","summary":"This week discusses control flow elements like conditionals and logical operators, which are essential for making decisions in code and controlling how it executes.","title":"Week 1: Conditionals","type":"projects"},{"content":" CS50‚Äôs Introduction to Programming with Python # Github repository # Here you can check the Github repository used trough the course.\nCertificate # Here you can see my certificate of the course.\nWeek 0: Functions, Variables # This week covers fundamental programming concepts including functions, data types, and debugging techniques, providing a foundational understanding for writing and troubleshooting code.\nKey concepts Concept Details Functions A block of code that performs a specific task. Bugs and Debugging Mistakes in the code and how to fix them. Data Types The type of data that a variable can store. Named Parameters Parameters that are passed by name. String Methods Methods that can be used with strings. Integers and Operators Operators that can be used with integers. Type Conversion Converting one data type to another. Week 1: Conditionals # This week discusses control flow elements like conditionals and logical operators, which are essential for making decisions in code and controlling how it executes.\nKey concepts Concept Details Comparison Operators Operators that compare two values. if A way to run code conditionally. elif A way to run code conditionally if the first condition is false. else A way to run code if all other conditions are false. or A way to combine conditions. not equal A way to check if two values are not equal. and A way to combine conditions. chains A way to combine multiple conditions. modulo A way to get the remainder of a division. boolean A way to represent true or false values. pythonic expressions A way to write code in a more concise way. match A way to match a value to a pattern. Week 2: Loops # This week focuses on loops in programming, detailing how to iterate over data structures using for and while loops, and discussing concepts such as nested loops and list iteration.\nKey concepts Concept Details Loops The ability of doing something multiple times. while A way to repeat a block of code while a condition is true. for A way to repeat a block of code a number of times. Validating input A way to ensure that the input is correct. Iteration with Lists A way to iterate over a list. len A way to get the length of a list. Dictionaries A way to store key-value pairs. List of Dictionaries A way to store a list of dictionaries. Nested Loops A way to have a loop inside another loop. Week 3: Exceptions # This week focuses on error management in Python, detailing different types of exceptions and methods to handle them, ensuring robust and error-free code execution.\nKey concepts Concept Details Exceptions A way to handle errors in the code. Syntax Error A mistake in the code that the Python interpreter cannot execute. ValueError An error that happens when you try to convert a string to a number, but the string is not a number. try, except A way to handle exceptions. NameError An error that happens when you try to use a variable that is not defined. else A way to run code if the try block does not raise an exception. Reprompting, break A way to reprompt the user if the input is not valid. get_int A way to create a function to get an integer from the user. pass A way to do nothing. function arguments A way to pass arguments to a function. raise A way to raise an exception. Week 4: Libraries # This week introduces the concept of libraries and modules in Python, explaining how to import and use them, along with mentioning popular libraries for statistical analysis and file handling.\nKey concepts Concept Details Libraries A piece of code that someone else wrote that you can use in your code. Modules A library that has one or more functions built into it. import To use a module, you have to import it. from The keyword to import a specific function from a module. statistics A built-in module in Python that has a set of functions to calculate statistics. Command-line Arguments, sys The sys module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. Packages, PyPI, pip Package: A collection of modules. PyPI: Python Package Index, a repository of software for Python. pip: a package installer for Python. Custom Libraries Create your own library. Week 5: Unit Tests # This week highlights the importance of testing in software development, discussing unit tests and the use of frameworks like pytest to ensure code quality and reliability.\nKey concepts Concept Details Unit Tests A way to test the code you wrote. assert A way to test the code you wrote. AssertionError A way to handle an AssertionError. pytest A testing framework that makes it easy to write small tests. Side Effects and Testing A way to test the code you wrote. Collection of Tests A way to group tests together. Week 6: File I/O # This week covers file input/output operations, explaining how to read and write data, manage file formats like CSV, and manipulate data structures such as lists and dictionaries.\nKey concepts Concept Details File I/O A way to read and write data to and from files. lists Data is stored in a list, but the moment the program is closed, the data is lost. open Used to open a file. with Used to open a file and automatically close it when the block is done. Reading from a file Use the read method to read the entire file, or readline to read one line at a time. sorted Used to sort a list. Comma-Separated Values (CSV) A file format used to store tabular data. sort keys Used to sort a list of dictionaries by a key. Lambda Functions A way to create small anonymous functions. CSV Library A library that can be used to read and write CSV files. Images, PIL Library A library that can be used to read and write images. Week 7: Regular Expressions # This week explores regular expressions as powerful tools for string matching and validation, detailing how to use them effectively within Python programs.\nKey concepts Concept Details Regular Expressions A pattern that we can use to match strings. Validation with Regular Expressions A way to validate strings using regular expressions. re Library A library that allows us to define a pattern to match strings. Regular Expressions Patterns A set of symbols that can be used to match strings. Week 8: Object-Oriented Programming # This week outlines the principles of OOP, including classes, objects, and inheritance, emphasizing how these concepts facilitate code organization and reuse.\nKey concepts Concept Details Object-Oriented Programming (OOP) A programming paradigm that uses \u0026ldquo;objects\u0026rdquo; to design applications and computer programs. Tuples A collection of objects that are ordered and immutable. Dictionaries A collection of key-value pairs that is more powerful than a list. Classes and Objects A class is a blueprint or a mold for creating objects. Instance Methods Functions defined inside a class used to perform operations on objects of that class. Types and Classes A type is a category of values, and a class is a blueprint for creating objects. Class methods Methods that are bound to the class and not the object of the class. Static methods Methods that are bound to the class and not the object of the class. Inheritance A way to create a new class that is based on an existing class. Operator Overloading A way to define how an operator behaves when used with a class. Week 9: Et Cetera # This week presents advanced programming features like sets, global variables, type hints, and comprehensions, enhancing Python‚Äôs functionality and readability while promoting best practices.\nKey concepts Concept Details set A collection of unique elements; an unordered collection of items. global Used to declare that a variable inside the function is global (outside the function). constants A type of variable whose value cannot be changed. Type Hints, mypy A static type checker for Python. Docstrings A string that appears right after the definition of a function, class, or module. argparse A module in the Python standard library that allows you to parse command-line arguments. unpacking A way to assign the elements of an iterable to multiple variables. map A function that applies a given function to each item of an iterable (list, tuple, etc.). List Comprehensions A way to create lists in Python. filter A function that filters elements of an iterable based on a given function. Dictionary Comprehensions A way to create dictionaries in Python. enumerate A function that adds a counter to an iterable. Generators, Iterators A way to create iterators in Python. Weeks in detail # ","date":"14 August 2024","externalUrl":null,"permalink":"/projects/cs50-python/","section":"Projects","summary":"Here you will find a short summary of the key concepts of each week of the CS50P course in addition to the posts on the detailed notes of each week.","title":"CS50-Python certification","type":"projects"},{"content":" Hello Bison in Python # print(\u0026#34;Hello Bison!\u0026#34;) Functions # We just used the print function.\nArgument: value passed to a function.\nSide effects: printing to the console.\nBugs and Debugging # Bugs: mistakes in the code.\nDebugging: finding and fixing bugs.\nReturn values and Variables # Return values: values returned by functions.\nVariables: store values for later use.\nComments and Pseudocode # Comments: notes to self and others.\nPseudocode: planning code before writing it.\nMultiple function arguments # String: a sequence of characters.\nConcateation: combining strings.\nTable of Data Types # Data Type Description int Integer numbers (e.g., 5, -3, 100) float Floating point numbers (e.g., 3.14, -0.001, 2.0) complex Complex numbers (e.g., 3 + 4j, -2.5 + 0.1j) str String (e.g., \u0026ldquo;hello\u0026rdquo;, \u0026lsquo;world\u0026rsquo;, \u0026ldquo;123\u0026rdquo;) list List (e.g., [1, 2, 3], [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]) tuple Tuple (e.g., (1, 2, 3), (\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;)) set Set (e.g., {1, 2, 3}, {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;}) dict Dictionary (e.g., {\u0026lsquo;key\u0026rsquo;: \u0026lsquo;value\u0026rsquo;}, {1: \u0026lsquo;one\u0026rsquo;, 2: \u0026rsquo;two\u0026rsquo;}) bool Boolean (True or False) bytes Immutable bytes sequence (e.g., b\u0026rsquo;hello\u0026rsquo;, b\u0026rsquo;\\x00\\x01\\x02\u0026rsquo;) Named Parameters # Documentation for print function # print(*objects, sep=\u0026#39; \u0026#39;, end=\u0026#39;\\n\u0026#39;, file=sys.stdout, flush=False) *objects: zero or more objects to print. sep: how to separate objects. end: what to print at the end. file: where to print. flush: whether to forcibly flush the stream. Parameters vs Arguments # Parameters: variables in the function definition. Arguments: values passed to the function. Small pieace of code to demonstrate how to change the end parameter behavior # print(\u0026#34;Hello \u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;Bison!\u0026#34;) The expected output is Hello Bison!.\nNamed parameters vs Positional parameters # Named parameters: they are optional and can be passed in any order. Positional parameters: they are required and must be passed in the correct order. Escaping Characters # Escape character: backslash (). f-strings # f-string: formatted string literal. Example of code using f-strings # name = \u0026#34;Bison\u0026#34; print(f\u0026#34;Hello, {name}!\u0026#34;) The expected output is Hello, Bison!.\nString Methods # .strip(): remove whitespace.\n.capitalize(): capitalize the first letter.\n.title(): capitalize the first letter of each word.\n.lstrip(): remove whitespace from the left.\n.rstrip(): remove whitespace from the right.\nExample of code using .strip() and .title() # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).strip().title() print(f\u0026#34;Hello, {name}!\u0026#34;) Style # Style: how code looks and is organized.\nPEP 8: Python Enhancement Proposal 8.\nsplit # .split(): split a string into a list. Example of code using .split() # names = input(\u0026#34;Enter names separated by commas: \u0026#34;).split(\u0026#34;, \u0026#34;) print(names) Expected output: ['Alice', 'Bob', 'Charlie'].\nIntegers and Operators # Integer: whole numbers.\nOperators: symbols that perform operations.\nTable of Operators # Operator Name Description + Addition Adds two numbers. - Subtraction Subtracts two numbers. * Multiplication Multiplies two numbers. / Division Divides two numbers. // Floor division Divides two numbers and rounds down. % Modulus Returns the remainder of the division. ** Exponentiation Raises a number to the power of another. Interactive mode # The interactive mode is a way to run Python code line by line.\nCalculator.py # x = input(\u0026#34;What\u0026#39;s x? \u0026#34;) y = input(\u0026#34;What\u0026#39;s y? \u0026#34;) z = x + y print(z) Type Conversion # Type conversion: converting one data type to another.\nint(): convert to integer.\nExample of code using int() # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) print(x + y) Foating Point Values # Floating point values: decimal numbers.\nfloat(): convert to floating point.\nExample of code using float() # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) print(x + y) Rounding Numbers # round(): round a number to a specified number of decimal places. round(number[, ndigits]) Example of code using round() # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = round(x + y) print(z) Numeric Formatting # f-string: formatted string literal. Example of code using f-string to format a number # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = round(x + y) print(f\u0026#34;{z:,}\u0026#34;) Division # /: division. Example of code using / and // # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = x / y print(f\u0026#34;{z:.2f}\u0026#34;) Defining Functions # def: define a function. Example of code defining a function # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) hello(name) def hello(to=\u0026#34;Bison\u0026#34;): print(\u0026#34;Hello \u0026#34;, to) main() Scope # Scope: where a variable is accessible. Return Values # return: return a value from a function. Example of code using return # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(\u0026#34;x squared is\u0026#34;, square(x)) def square(n): return pow(n, 2) main() ","date":"18 April 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_0/","section":"Projects","summary":"This week covers fundamental programming concepts including functions, data types, and debugging techniques, providing a foundational understanding for writing and troubleshooting code.","title":"Week 0: Functions, Variables","type":"projects"},{"content":"Hey, welcome to my corner of the internet! I love experimenting with new stuff. One minute, I‚Äôm checking out an app, and the next, it‚Äôs 3 AM and I‚Äôm deep into Linux kernel docs. I‚Äôm into coding (mostly Python, Go, and Bash, the SRE/Cloud stack), setting up powerful servers, and quirky projects like building custom keyboard layouts.\nI spend a lot of time in open-source communities, learning and sharing along the way. Here, you‚Äôll find a mix of my projects, tech stories (wins and losses) and maybe some class notes. I used to dump everything on GitHub, but decided it‚Äôs easier to organize it all here instead.\nNo big plans for fame or money, just sharing what I know and what I‚Äôm learning. Feel free to poke around!\n","date":"26 January 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" LAN Interconnection: University Course Notes # About This Blog # This blog documents my study journey for the university course \u0026ldquo;LAN Interconnection\u0026rdquo;. Each chapter includes theoretical notes and hands-on labs using Cisco Packet Tracer (.pkt files) to simulate network scenarios.\nChapters # Chapter 1: IP Routing Overview # This chapter introduces foundational concepts of IP routing, including Internet architecture, BGP basics, and router functionalities.\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapter 2: Static Routing # Chapter overview\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapter 3: Dynamic Routing # Chapter overview\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapter 4: RIP \u0026amp; EIGRP # Chapter overview\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapter 5: OSPF Fundamentals # Chapter overview\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapter 6: Advanced OSPF # Chapter overview\nLabs:\nLab x: name Lab y: name Key concepts Concept Details placeholder placeholder Chapters # ","date":"26 January 2025","externalUrl":null,"permalink":"/projects/lan_interconnection/","section":"Projects","summary":"Rework of the documents from my LAN interconnections class and their explained labs.","title":"LAN interconnection","type":"projects"},{"content":"","date":"26 January 2025","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"22 October 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Key Management # aaKey management involves managing keys throughout their entire lifecycle, from creation to destruction, including their use, storage, assignment, creation, and destruction.\nThis allows us to maintain a secure ecosystem, where each user can have access to different permissions with a single key, similar to how master keys used to work.\nKeys can be symmetric (single key) for information that will be \u0026ldquo;at rest\u0026rdquo; (meaning it won\u0026rsquo;t travel through any medium) such as the keys themselves, or asymmetric (two keys) for information that will be \u0026ldquo;traveling\u0026rdquo; between different media.\nTypically, a mixture of both cryptographic systems is used, using an asymmetric system to send a symmetric key, since symmetric cryptography is faster but cannot securely transmit the key by itself, so an asymmetric system is used to share the key.\nSymmetric keys are symmetrically encrypted on a KM (key manager) server, so the user has to send their certificate (asymmetric cryptography) to the KM server to compare it with the certificate authority, which verifies if they are actually who they claim to be.\nOnce this is done, the server sends its certificate to the client to establish a connection, and then the KM server decrypts the symmetric key (with another symmetric key) and sends it to the user through a TLS channel.\nAsymmetric keys follow a similar path, except that instead of using a TLS channel, it uses the public key of each encryption (user and server) to securely share a symmetric key through a channel (which might not be secure), and in turn, the information encrypted with the symmetric key.\nAuthentication Process and Symmetric Encryption with Certificates # Validation Process and Asymmetric Encryption on a KM Server # Trusted Platform Module and TPM Uses # It is basically a crypto-processor, a physical chip that can come as an add-on, as shown in the photograph, or can be embedded in the motherboard. This chip is responsible for storing keys and processing complex cryptographic systems, assisting the processor (CPU) while being more secure since it can only connect with the processor, preventing unknown hardware from copying the keys or modifying its operation.\nAmong the things that can be done, the TPM can validate your identity using specific crypto-processor keys (which cannot be modified) or even keys from other applications that are stored within it.\nIt can also validate the operating system by analyzing signed components, and if the signatures don\u0026rsquo;t match, it\u0026rsquo;s probably because the file has been modified, which could indicate some type of infection (this is normally what prevents \u0026ldquo;secure boot\u0026rdquo;).\nDifferent uses for the TPM chip # DRM (Digital Rights Management) File and folder encryption Secure email SSL VPN One-time passwords Account management Two-Factor Authentication with chip keys Chip Components # Random number generator Cryptographic key generation Secure key storage Hashes Internet Security # We find cryptography in many different places, especially where some type of authentication is needed, particularly when passwords or certificates are used.\nThere are 3 authentication methods:\nSymmetric cryptography is for information not in transit, due to its speed and ease of key management.\nAsymmetric cryptography is for information in transit, typically used for session management, and once the connection is established, symmetric cryptography is used for sending large volumes of information.\nThe Problem of Password Security Management # Storage # Passwords should not be stored in plain text, which leads to the idea of storing them as a hash, so that if an attacker steals them, they cannot be reversed.\nHash Functions # Cryptographic hash functions ‚â† Password hash functions The main problem is that cryptographic hash functions are not designed for passwords. They tend to be very fast, and generally this would be good, if it weren\u0026rsquo;t because this benefits an attacker who wants to perform a brute force attack.\nRecognition # The first step is to check if the password is already in some rainbow table on the internet or similar; if not, proceed with the brute force attack.\nSpeed # Speed plays a crucial role, so if the hashing method is very fast (say 0.1 seconds), the password can be broken in relatively little time, so we seek to keep the hashing process above 0.1 seconds, preferably close to 1 second speed.\nSalt # Salt is a randomly generated set of letters for each user that changes the output hash, making it (computationally impossible) for the attacker to find the user\u0026rsquo;s password generated in a rainbow table on the internet.\nPepper # Like salt, pepper also changes the final hash, but it\u0026rsquo;s usually within the source code. This is useful if for some reason the database where we\u0026rsquo;re storing passwords isn\u0026rsquo;t secure, or we can\u0026rsquo;t trust the traffic from the application to the database. We can add pepper to the source code as an extra security measure.\nExtension # PBKDF2 bcrypt scrypt Argon2 In these algorithms, the goal is to iterate the use of different hashes and salts to delay the process of obtaining the password hash, and thus strengthen our application against brute force attacks.\nThe POODLE attack (Padding Oracle On Downgraded Legacy Encryption) is relevant here. For SSL 3.0, only 256 requests were needed to reveal one byte of communication. This attack takes advantage of a mechanism that reduces security in order to maintain interoperability.\nFor TLS 1.0 to 1.2, the attack is based on flaws in CBC encryption.\nSSL Handshake # Used to establish the encryption method that will be maintained throughout the communication and session data.\nContact and capability establishment: RSA Authenticated Diffie-Hellman Anonymous Diffie-Hellman Fortezza Key exchange and server authentication Key exchange and client authentication Protocol finalization (session keys are created here) SSL Record # Used to transmit information between client and server.\nMessage data Message fragmentation Fragment compression Addition of a message authentication code Data encryption Header addition Sending the cryptogram through TCP File Transfer Protocol # Contains no security layer.\nFile Transfer Protocol / SSL: # It\u0026rsquo;s the same FTP protocol but over SSL protocol (currently TLS).\nSSH File Transfer Protocol # It\u0026rsquo;s a protocol created from scratch, very different from FTP, that works based on SSH.\nSecure Copy Protocol # Based on:\nSSH FTP RCP commands ","date":"22 October 2024","externalUrl":null,"permalink":"/posts/crypt_exam_2/","section":"Posts","summary":"This post is a rewrite of the summary document provided by the professor that includes only the topics from exam 2.","title":"Summary of Cryptography Exam 2","type":"posts"},{"content":" 1. Variables and Data Types # In Python, variables are declared by simply assigning them a value:\nname = \u0026#34;Alice\u0026#34; # String age = 25 # Integer height = 1.65 # Float is_student = True # Boolean 2. Control Structures # Conditionals # if age \u0026gt;= 18: print(\u0026#34;You are an adult\u0026#34;) elif age \u0026gt;= 13: print(\u0026#34;You are a teenager\u0026#34;) else: print(\u0026#34;You are a child\u0026#34;) Loops # For Loop # for i in range(5): print(i) # Prints 0 to 4 While Loop # counter = 0 while counter \u0026lt; 5: print(counter) counter += 1 3. Functions # Defining and using functions:\ndef greet(name): return f\u0026#34;Hello, {name}!\u0026#34; message = greet(\u0026#34;John\u0026#34;) print(message) # Prints: Hello, John! 4. Lists and Dictionaries # Lists # fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] fruits.append(\u0026#34;date\u0026#34;) print(fruits[1]) # Prints: banana Dictionaries # person = { \u0026#34;name\u0026#34;: \u0026#34;Charles\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34; } print(person[\u0026#34;city\u0026#34;]) # Prints: New York 5. Modules # Importing and using modules:\nimport random number = random.randint(1, 10) print(f\u0026#34;Random number: {number}\u0026#34;) 6. Exception Handling # try: result = 10 / 0 except ZeroDivisionError: print(\u0026#34;Error: Division by zero\u0026#34;) finally: print(\u0026#34;Operation completed\u0026#34;) 7. List Comprehensions # squares = [x**2 for x in range(5)] print(squares) # Prints: [0, 1, 4, 9, 16] Note: This guide covers the basics of Python. For more information, please refer to the official Python documentation.\n","date":"4 October 2024","externalUrl":null,"permalink":"/posts/python_basics/","section":"Posts","summary":"This is another test post in which I give a really simple and brief python guide","title":"Python Quick Guide","type":"posts"},{"content":" What\u0026rsquo;s Linux? # Linux is an open-source operating system that dates back to the early 1990s. Its journey began in 1991, when Linus Torvalds, a Finnish computer science student, embarked on creating a kernel based on Unix principles.\nKey Events in Linux History # August 25, 1991:\nLinus posted a now-famous message on the Usenet group comp.os.minix, stating:\n\u0026ldquo;I\u0026rsquo;m doing a (free) operating system (just a hobby, won\u0026rsquo;t be big and professional like gnu)\u0026hellip;\u0026rdquo;\nOctober 1991:\nLinux version 0.02 was released, containing the basic core components that would eventually evolve into the modern Linux kernel.\nThe Role of the GNU Project # Linux combined with GNU (a project started by Richard Stallman to create a free Unix-like operating system) formed the basis of what is now called GNU/Linux. The GNU tools, such as the GNU Compiler Collection (GCC) and Bash shell, were integral to the success of Linux.\nLinux Today # Today, Linux is everywhere:\nServers\nLinux powers over 90% of the servers that run the internet.\nCloud Computing\nLinux is at the heart of major cloud platforms like AWS, Google Cloud, and Azure.\nEmbedded Systems\nLinux is used in devices ranging from smartphones to IoT gadgets.\nDid You Know? # The Linux mascot, a penguin named Tux, was chosen by Torvalds after he was once bitten by a penguin at a zoo. üêß\nLinux Kernel Version Table # Version Release Date Key Features 1.0 March 1994 First stable release of the kernel. 2.4 January 2001 Added support for USB, IPv6, and more. 3.0 July 2011 Improved scalability and ARM support. 4.0 April 2015 Introduced live patching capabilities. 5.0 March 2019 Better hardware support, energy efficiency improvements. Conclusion # From its humble beginnings as a hobby project, Linux has grown into a global phenomenon. Thanks to the power of open-source collaboration, it has become the backbone of modern computing, shaping the internet, cloud services, and even smart devices.\nLearn More About Linux\n","date":"4 October 2024","externalUrl":null,"permalink":"/posts/linux_history/","section":"Posts","summary":"This is a post where I summarize the history of linux, it is a test post.","title":"The History of Linux","type":"posts"},{"content":" Topology # In packet tracer # In a real enviorment # 1. Network redundancy # In the proposed topology each outgoing switch of each department has two outputs, the main switch and the backup switch so we would have an STP with the root on the main switch and the secondary root on the backup switch, so if it fails they could simply send their packets through the secondary without any problem.\nDepartment Number of LAN switch ports Sales 12 Engineering 2.1 48 Engineering 2.2 12 Administration 24 Marketing 48 2. Configuration of each LAN switch # Switch Configuration 1 - vlan 10 - name sales - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 10 2.1 - vlan 20 - name engineering - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 20 2.2 - vlan 20 - name engineering - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 20 3 - vlan 30 - name administration - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 30 4 - vlan 40 - name marketing - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 40 3. Router to the Internet # In this case we have the ‚ÄúMain‚Äù and ‚ÄúBackup‚Äù switches so they will do the inter-VLAN routing so we don\u0026rsquo;t need to have something like a Router-On-A-Stick to do the VLAN routing.\n4. EtherChannel # It is possible to add an EtherChannel in any of the switches, a practical example would be in the case that for example, engineering grows and now needs much more bandwidth or something like that, here is a generic example of the configuration to make an EtherChannel between two switches:\nIn the switch1\ninterface range GigabitEthernet1/0/1 - 2 description Link_to_switch2_Switch switchport mode trunk channel-group 1 mode active channel-protocol lacp In the switch2\ninterface range GigabitEthernet1/0/1 - 2 description Link_to_switch1_Switch switchport mode trunk channel-group 1 mode active channel-protocol lacp Once configured, EtherChannel will group the selected ports on both switches into a single logical ‚Äúchannel‚Äù. This means that the combined bandwidth of the physical links will be used to carry traffic between switch1 and switch2. If one of the physical links fails, traffic is automatically rerouted over the other link without manual intervention, maintaining connectivity and performance.\nImplementing EtherChannel will significantly improve network performance between these two critical departments and help to efficiently handle large volumes of traffic, while also ensuring higher availability and redundancy.\n5. IP addressing scheme # There will be 4 VLANS:\nSales: 10 users Administration: 20 users Marketing: 35 users Engineering: 50 users Department Range of useful IPs VLAN number Sales 192.168.10.0 - 192.168.10.30 10 Engineering 192.168.10.128 - 192.168.10.190 20 Administration 192.168.10.32 - 192.168.10.62 30 Marketing 192.168.10.64 - 192.168.10.126 40 6. Gateway and PC masks for each department # Department Gateway Mask Sales 192.168.10.1 255.255.255.224 Engineering 192.168.10.129 255.255.255.192 Administration 192.168.10.33 255.255.255.224 Marketing 192.168.10.65 255.255.255.192 7. LAN switches main switch # The idea in this topology is that the main switch is the one called ‚ÄúMain‚Äù, the command used to see if the switch is the main switch or not is:\n# show spanning-tree Once this command is executed it will give you an output like this:\nSwitch#show spanning-tree VLAN0001 Spanning tree enabled protocol ieee Root ID Priority 32769 Address 0002.1770.0A10 This bridge is the root Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec Bridge ID Priority 32769 (priority 32768 sys-id-ext 1) Address 0002.1770.0A10 Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec Aging Time 20 Interface Role Sts Cost Prio.Nbr Type ----------- ---- --- --------- -------- ---- Fa0/2 Desg FWD 19 128.2 P2p Fa0/5 Desg FWD 19 128.5 P2p Fa0/1 Desg FWD 19 128.1 P2p Where you can see in the third line of the ‚ÄúRoot ID‚Äù section that this is the ‚ÄúBridge root‚Äù or the main root switch.\n8. LAN switches secondary switch # In this case, as the name indicates, the idea is that the router called ‚ÄúBackup‚Äù acts as the secondary.\nThe command that would be used would be the same way the show spanning-tree and in the legend that says in the previous image ‚ÄúThis bridge is the root‚Äù will say that it is the secondary.\n9. Separate STP by VLAN # Given the size of the network and the separation into several departments with different connectivity requirements, it would be possible to implement PVST+. Implementing it could improve operational efficiency by allowing different root paths for different VLANs, plus it is likely that it could increase overall network stability by pinpointing potential STP problems to individual VLANs, preventing a problem in one VLAN from affecting the entire network.\nImplementing PVST+ can maximize the use of all available links and provide a better user experience by optimizing network traffic based on the specific needs of each department.\n10. Recommended commands for STP security # Inside each interface connected to a PC\nspanning-tree portfast: this is not for security but it is highly recommended to use it on interfaces going to end devices like PCs.\nspanning-tree bpduguard enable: this command makes sure that if an interface put in portfast mode for a PC for example and then connects a device capable of sending BPDU packets such as a switch this BPDU packet does not break the spanning-tree, turning off the interface to achieve this.\n","date":"25 May 2024","externalUrl":null,"permalink":"/posts/local-network-switching/","section":"Posts","summary":"This was my final project of the local network switching class, it is a document about the implementation of all the topics seen during the semester.","title":"Local Network Switching - Final Project","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]
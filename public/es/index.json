


[{"content":" set # A set is a collection of unique elements. It is an unordered collection of items. Sets are used to store multiple items in a single variable. It is a collection data type in Python.\nDoumentation\nExample without using set # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] houses = [] for student in students: if student[\u0026#34;house\u0026#34;] not in houses: houses.append(student[\u0026#34;house\u0026#34;]) for house in sorted(houses): print(house) Example without re-inveting the wheel: using set # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] houses = set() for student in students: houses.add(student[\u0026#34;house\u0026#34;]) for house in sorted(houses): print(house) global # The global keyword is used to declare that a variable inside the function is global (outside the function). If you want to change a global variable inside a function, you can use the global keyword to declare which variables are global.\nExample where you use a variable that lives outside the function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code that tries to change a global variable inside a function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) deposit(100) withdraw(50) print(\u0026#34;Balance:\u0026#34;, balance) def deposit(n): balance += n def withdraw(n): balance -= n if __name__ == \u0026#34;__main__\u0026#34;: main() The result is a UnboundLocalError because the variable balance is not defined inside the function deposit.\nApparently is okey to read a global variable inside a function, but if you want to change it, you need to use the global keyword.\nExample of code that changes a global variable inside a function # balance = 0 def main(): print(\u0026#34;Balance:\u0026#34;, balance) deposit(100) withdraw(50) print(\u0026#34;Balance:\u0026#34;, balance) def deposit(n): global balance balance += n def withdraw(n): global balance balance -= n if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code with OOP # class Account: def __init__(self): self._balance = 0 @property def balance(self): return self._balance def deposit(self, n): self._balance += n def withdraw(self, n): self._balance -= n def main(): account = Account() print(\u0026#34;Balance:\u0026#34;, account.balance) account.deposit(100) account.withdraw(50) print(\u0026#34;Balance:\u0026#34;, account.balance) if __name__ == \u0026#34;__main__\u0026#34;: main() Usually using global variables is not a good practice. It is better to use classes and objects.\nNote for myself: the instance variable balance and all the other instance variables by definition can be accessed by all the methods of the class.\nconstants # A constant is a type of variable whose value cannot be changed.\nExample of code with \u0026ldquo;constants\u0026rdquo; # MEOWS = 3 for _ in range(MEOWS): print(\u0026#34;meow\u0026#34;) There\u0026rsquo;s actually no way to define a constant in Python. The convention is to use uppercase letters for the variable name to indicate that it should be treated as a constant.\nConstants in OOP # class Cat: MEOWS = 3 def meow(self): for _ in range(Cat.MEOWS): # or self.MEOWS print(\u0026#34;meow\u0026#34;) cat = Cat() cat.meow() Type Hints, mypy # mypy is a static type checker for Python. It is a tool that can be used to check the types of variables and functions in your code.\nDocumentation\nExample of code where an error is detected by mypy # def meow(n): for _ in range(n): print(\u0026#34;meow\u0026#34;) number = input(\u0026#34;Number: \u0026#34;) meow(number) MyPy will detect the error because the function input returns a string, and the function meow expects an integer.\nExample of code with type hints # def meow(n: int): for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = input(\u0026#34;Number: \u0026#34;) meow(number) The code is still wrong, but now mypy can detect the error much quicker by adding type hints.\nCorrect version of the code # def meow(n: int): for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = int(input(\u0026#34;Number: \u0026#34;)) meow(number) Return type hints: error version # def meow(n: int) -\u0026gt; None: for _ in range(n): print(\u0026#34;meow\u0026#34;) number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows) Return type hints: correct version # def meow(n: int) -\u0026gt; str: return \u0026#34;meow\\n\u0026#34; * n number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows, end=\u0026#34;\u0026#34;) Docstrings # A docstring is a string that is used to document a function, method, or class. It is used to describe what the function does, what parameters it takes, and what it returns.\nThere\u0026rsquo;s a standarized way on how to document your functions, methods, and classes in Python, the PEP (Python Enhancement Proposal) is the PEP 257\nExample of code with a docstring # def meow(n: int) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Meow n times. :param n: Number of times to meow. :type n: int :raise TypeError: If n is not an int. :return: A string of n meows, one per line. :rtype: str \u0026#34;\u0026#34;\u0026#34; return \u0026#34;meow\\n\u0026#34; * n number: int = int(input(\u0026#34;Number: \u0026#34;)) meows: str = meow(number) print(meows, end=\u0026#34;\u0026#34;) argparse # The argparse module is used to parse command-line arguments in Python. It is a standard module that comes with Python.\nDocumentation\nExample of code with argparse # import argparse parser = argparse.ArgumentParser(description=\u0026#34;Meow like a cat.\u0026#34;) parser.add_argument(\u0026#34;-n\u0026#34;, default=1, help=\u0026#34;number of times to meow\u0026#34;, type=int) args = parser.parse_args() for _ in range(args.n): print(\u0026#34;meow\u0026#34;) Note: if you specify that the argument is a type int, you don\u0026rsquo;t need to convert it to an integer.\nunpacking # Unpacking is the process of extracting values from a collection, such as a list or a tuple, and assigning them to variables.\nA very simple example of unpacking # first, _ = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).split(\u0026#34; \u0026#34;) # Here is the unpacking print(f\u0026#34;hello, {first}\u0026#34;) We used the foo, bar = \u0026quot;foo bar\u0026quot;.split(\u0026quot; \u0026quot;) to unpack the values of the list returned by the split method.\nUnpacking a list # def total(galleons, sickles, knuts): return (galleons * 17 + sickles) * 29 + knuts coins = [100, 50, 25] print(total(*coins), \u0026#34;Knuts\u0026#34;) # Here is the unpacking We used the * operator to unpack the values of the list coins and pass them as arguments to the function total.\nUnpacking a dictionary # def total(galleons, sickles, knuts): return (galleons * 17 + sickles) * 29 + knuts coins = {\u0026#34;galleons\u0026#34;: 100, \u0026#34;sickles\u0026#34;: 50, \u0026#34;knuts\u0026#34;: 25} print(total(**coins), \u0026#34;Knuts\u0026#34;) # Here is the unpacking We used the ** operator to unpack the values of the dictionary coins and pass them as arguments to the function total.\n*args and **kwargs # *args is used to pass a variable number of arguments to a function. **kwargs is used to pass a variable number of keyword arguments to a function. def f_positional(*args, **kwargs): print(\u0026#34;Positional:\u0026#34;, args) # The output of this function is: Positional: (100, 50, 25) f_positional(100, 50, 25) def f_keyword(*args, **kwargs): print(\u0026#34;Keyword:\u0026#34;, kwargs) # The output of this function is: Keyword: {\u0026#39;galleons\u0026#39;: 100, \u0026#39;sickles\u0026#39;: 50, \u0026#39;knuts\u0026#39;: 25} f_keyword(galleons=100, sickles=50, knuts=25) map # The map function is used to apply a function to each item in a list or other iterable.\nmap(function, iterable) Documentation\nExample of code without using map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): uppercased = [] for word in words: uppercased.append(word.upper()) print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() Example of code using map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): \u0026#34;\u0026#34;\u0026#34; We use str.upper instead of something.upper() because instead of actually applying the method to the string, we are just passing the method itself to the map function. \u0026#34;\u0026#34;\u0026#34; uppercased = map(str.upper, words) print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() List Comprehensions # List comprehensions are a concise way to create lists in Python. They are used to create a new list by applying an expression to each item in an existing list.\nExample of code using a list comprehension instead of a for loop or map # def main(): yell(\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;CS50\u0026#34;) def yell(*words): uppercased = [word.upper() for word in words] print(*uppercased) if __name__ == \u0026#34;__main__\u0026#34;: main() filter # The filter function is used to filter items from a list or other iterable.\nfilter(function, iterable) Documentation\nExample of code without using filter # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] gryffindors = [ student[\u0026#34;name\u0026#34;] for student in students if student[\u0026#34;house\u0026#34;] == \u0026#34;Gryffindor\u0026#34; ] for gryffindor in sorted(gryffindors): print(gryffindor) In the code above, we used a list comprehension with a conditional to filter the students that belong to the house Gryffindor.\nExample of code using filter # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Padma\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Ravenclaw\u0026#34;}, ] def is_gryffindor(s): return s[\u0026#34;house\u0026#34;] == \u0026#34;Gryffindor\u0026#34; gryffindors = filter(is_gryffindor, students) for gryffindor in sorted(gryffindors, key=lambda s: s[\u0026#34;name\u0026#34;]): print(gryffindor[\u0026#34;name\u0026#34;]) Dictionary Comprehensions # Dictionary comprehensions are a concise way to create dictionaries in Python. They are used to create a new dictionary by applying an expression to each item in an existing dictionary.\nExample of code not using a dictionary comprehension # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] gryffindors = [] for student in students: gryffindors.append({\u0026#34;name\u0026#34;: student, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;}) print(gryffindors) Example of code using a dictionary comprehension # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] gryffindors = {student: \u0026#34;Gryffindor\u0026#34; for student in students} print(gryffindors) enumerate # The enumerate function is used to add a counter to an iterable.\nenumerate(iterable, start=0) Documentation\nExample of code without using enumerate # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i in range(len(students)): print(i + 1, students[i]) Example of code using enumerate # students = [\u0026#34;Hermonie\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i, student in enumerate(students, start=1): print(i + 1, student) Generators, Iterators, yield # A generator is a function that returns an iterator. It generates values using the yield keyword.\nWhat\u0026rsquo;s a generator?\nExample of code that not works due the lack of using a generator # def main(): n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) for i in range(n): print(sheep(i)) def sheep(n): flock = [] for i in range(n): flock.append(\u0026#34;🐑\u0026#34; * i) return flock if __name__ == \u0026#34;__main__\u0026#34;: main() The problem in the code above is that the function sheep first generates all the values and then returns them all at once. This is not efficient because it uses a lot of memory.\nExample of code using a generator # def main(): n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) for i in range(n): print(sheep(i)) def sheep(n): for i in range(n): yield \u0026#34;🐑\u0026#34; * i if __name__ == \u0026#34;__main__\u0026#34;: main() The word yield is used to return a value at the time, that way we don\u0026rsquo;t need to store all the values in memory but just one at a time.\nyeild is returning an iterator, so we can use it in a for loop.\n","date":"12 agosto 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_9/","section":"Projects","summary":"A set is a collection of unique elements. It is an unordered collection of items. Sets are used to store multiple items in a single variable. It is a collection data type in Python.","title":"Week 9: Et Cetera","type":"projects"},{"content":" Object-Oriented Programming (OOP) # Object-Oriented Programming (OOP) is a programming paradigm that uses \u0026ldquo;objects\u0026rdquo; to design applications and computer programs. It utilizes several techniques from previously established paradigms, including modularity, polymorphism, and encapsulation. OOP is based on the concept of \u0026ldquo;objects,\u0026rdquo; which can contain data in the form of fields, often known as attributes, and code in the form of procedures, often known as methods.\nTuples # A tuple is a collection of objects that are ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\ndef main(): student = get_student() print(f\u0026#34;{name} from {house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return name, house if __name__ == \u0026#34;__main__\u0026#34;: main() Dictionaries # A dictionary is a little bit more powerful than a list. It is a collection of key-value pairs. Dictionaries are used to store data values in key:value pairs.\ndef main(): student = get_student() if student[\u0026#34;name\u0026#34;] == \u0026#34;Padma\u0026#34;: student[\u0026#34;house\u0026#34;] = \u0026#34;Ravenclaw\u0026#34; print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} from {student[\u0026#39;house\u0026#39;]}\u0026#34;) def get_student(): return student = { \u0026#34;name\u0026#34;: input(\u0026#34;Name: \u0026#34;), \u0026#34;house\u0026#34;: input(\u0026#34;House: \u0026#34;) } if __name__ == \u0026#34;__main__\u0026#34;: main() Classes and Objects # A class is a blueprint or a mold for creating objects.\nA class is a user-defined blueprint or prototype from which objects are created.\nAn object is an instance of a class that has attributes and methods.\nDocumentation\nSimple use of a class # class Student: ... def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): student = Student() student.name = input(\u0026#34;Name: \u0026#34;) student.house = input(\u0026#34;House: \u0026#34;) return student if __name__ == \u0026#34;__main__\u0026#34;: main() Instance Methods # Table of methods # Method Description __init__() Constructor method, called when a new instance is created. __del__() Destructor method, called when an instance is about to be destroyed. __repr__() Returns an official string representation of the instance, useful for debugging. __str__() Returns a readable string representation, used by print(). __call__() Allows an instance to be called as a function. __eq__() Defines behavior for the equality operator ==. __ne__() Defines behavior for the inequality operator !=. __lt__() Defines behavior for the less-than operator \u0026lt;. __le__() Defines behavior for the less-than-or-equal-to operator \u0026lt;=. __gt__() Defines behavior for the greater-than operator \u0026gt;. __ge__() Defines behavior for the greater-than-or-equal-to operator \u0026gt;=. __len__() Defines behavior for the built-in len() function. __getitem__() Defines behavior for indexing obj[key]. __setitem__() Defines behavior for assigning to indexed elements obj[key] = value. __delitem__() Defines behavior for deleting indexed elements del obj[key]. __iter__() Defines behavior for the iterator protocol. __next__() Defines behavior for retrieving the next item from an iterator. __contains__() Defines behavior for the membership test operators in and not in. __enter__() Defines behavior for entering a context (used with with statement). __exit__() Defines behavior for exiting a context (used with with statement), handles exceptions. __getattr__() Defines behavior for accessing an attribute that does not exist. __setattr__() Defines behavior for setting an attribute\u0026rsquo;s value. __delattr__() Defines behavior for deleting an attribute. __hash__() Defines behavior for the built-in hash() function. __eq__() Defines behavior for the equality operator ==. __ne__() Defines behavior for the inequality operator !=. The Constructor Method: __init__ # The __init__ method is a special method in Python classes that is called when a new instance of the class is created. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() The String Method: __str__ # The __str__ method is called by the str() built-in function and by the print() function to compute the \u0026ldquo;informal\u0026rdquo; or nicely printable string representation of an object. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def main(): student = get_student() print(f\u0026#34;{student.name} from {student.house}\u0026#34;) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Custom Methods # class Student: def __init__(self, name, house, patronus): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self.name = name self.house = house self.patronus = patronus def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def charm(self): match self.patronus: case \u0026#34;Stag\u0026#34;: return \u0026#34;🐴\u0026#34; case \u0026#34;Otter\u0026#34;: return \u0026#34;🦦\u0026#34; case \u0026#34;Jack Russell Terrier\u0026#34;: return \u0026#34;🐶\u0026#34; case _: return \u0026#34;🦄\u0026#34; def main(): student = get_student() print(\u0026#34;Expecto Patronum!\u0026#34;) print(sudent.charm()) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) patronus = input(\u0026#34;Patronus: \u0026#34;) return Student(name, house, patronus) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Properties, Getters, and Setters # Properties are a special kind of attribute that can be accessed like an attribute, but are computed like a method. @property is a decorator that allows you to define a method that can be accessed like an attribute. Getters are methods that allow you to access the value of a property. Setters are methods that allow you to change the value of a property. class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; # Getter \u0026#39;\u0026#39;\u0026#39; This is the getter method. This is the \u0026#34;function\u0026#34; that will be called when you try to get the value of the property. like this: print(student.house) \u0026#39;\u0026#39;\u0026#39; @property def house(self): return self._house # Setter \u0026#39;\u0026#39;\u0026#39; This is the setter method. This is the \u0026#34;function\u0026#34; that will be called when you try to set the value of the property. like this: student.house = \u0026#34;Gryffindor\u0026#34; \u0026#39;\u0026#39;\u0026#39; @house.setter def house(self, house): if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self._house = house def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; print(student) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Types and Classes # All this time int was a class: class int(x, base=10). The str has been a class all along: class str(object=''). All the time we used str.lower() we have been taking an object of class str and calling the method lower on it. str.strip([chars]) is the same thing, a method of the str class. list is a class, everytime we created a list we were creating an object of the class list: class list([iterable]). list.append(x) is a method of the list class. dict is a class, everytime we created a dictionary we were creating an object of the class dict: class dict(**kwarg). A small example # print(type(50)) print(type(\u0026#34;Hello, World!\u0026#34;)) print(type([])) print(type({})) Output:\n\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;list\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; Class methods # Sometimes is not really necessary to associate a function with object of a class but rather with the class itself.\nSometimes you want that the class have certain behaivor or certain functionality that is not related to the object itself but rather to the class. That means that no matter how is the object created, the class will have that functionality.\nFor that he got another decorator called @classmethod, we use this decorator to define a method that is associated with the class rather than the object.\nSorting hat example # In this example we\u0026rsquo;re gonna implement a sorting hat that will assign a house to a student.\nimport random class Hat: def __init__(self): self.houses = [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;] def sort(self, name): print(name, \u0026#34;is in\u0026#34;, random.choice(self.houses)) hat = Hat() hat.sort(\u0026#34;Harry\u0026#34;) Class method example # The code of above works but it\u0026rsquo;s not really necessary to create an object of the class Hat to sort a student.\nAnd it has a feature/bug, you can create more than one hat, and that\u0026rsquo;s not a functionality that we want. We could do something like this:\nhat1 = Hat() hat2 = Hat() hat3 = Hat() In the world of harry potter the sorting hat is not an object that you can create, it\u0026rsquo;s just one and only one hat that you put on the head of the student and it will sort the student.\nWe have been using instance methods: writing functions inside of classes that are automatically passed a reference to self, the current object, but sometimes you don\u0026rsquo;t need that, sometimes it suffices to just know what the class is and assume that might not even be an object of that class.\nSo in this case we can use a class really as a container for data and/or functions that is somehow conceptually related to the class but not necessarily to the object. Here is where @classmethod comes in.\nimport random class Hat: # This is a list of houses that is shared by all the instances of the class houses = [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;] @classmethod def sort(cls, name): # We dont reference self, we reference cls now which is the class itself print(name, \u0026#34;is in\u0026#34;, random.choice(cls.houses)) Hat.sort(\u0026#34;Harry\u0026#34;) Class method example 2: improving old code # This is the first version of students.py: # class Student: def __init__(self, name, house): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; # Getter \u0026#39;\u0026#39;\u0026#39; This is the getter method. This is the \u0026#34;function\u0026#34; that will be called when you try to get the value of the property. like this: print(student.house) \u0026#39;\u0026#39;\u0026#39; @property def house(self): return self._house # Setter \u0026#39;\u0026#39;\u0026#39; This is the setter method. This is the \u0026#34;function\u0026#34; that will be called when you try to set the value of the property. like this: student.house = \u0026#34;Gryffindor\u0026#34; \u0026#39;\u0026#39;\u0026#39; @house.setter def house(self, house): if house not in [\u0026#34;Gryffindor\u0026#34;, \u0026#34;Hufflepuff\u0026#34;, \u0026#34;Ravenclaw\u0026#34;, \u0026#34;Slytherin\u0026#34;]: raise ValueError(\u0026#34;Invalid house\u0026#34;) self._house = house def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; print(student) def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Let\u0026rsquo;s do some clean up to focus on the important parts: # class Student: def __init__(self, name, house): self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; def main(): student = get_student() student.house = \u0026#34;Number Four, Privet Drive\u0026#34; def get_student(): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return Student(name, house) #Constructor call if __name__ == \u0026#34;__main__\u0026#34;: main() Let\u0026rsquo;s improve the code using class methods # The original code wasn\u0026rsquo;t bad, but might be a little weird in the long run to have a function related to the class as a separate function outside of the class such as get_student().\nSo what we can do is to move that function inside of the class and make it a class method.\nclass Student: def __init__(self, name, house): self.name = name self.house = house def __str__(self): return f\u0026#34;{self.name} from {self.house}\u0026#34; @classmethod def get(cls): name = input(\u0026#34;Name: \u0026#34;) house = input(\u0026#34;House: \u0026#34;) return cls(name, hosue) def main(): student = Student.get() print(student) if __name__ == \u0026#34;__main__\u0026#34;: main() Satic methods # @staticmethod is a decorator that allows you to define a method that does not operate on the instance of the class or the class itself.\nAnyway this is a rabbit hole that the course will not go down, but it\u0026rsquo;s good to know that it exists.\nInheritance # Turns out, via OOP (Object Oriented Programming), there\u0026rsquo;s an opportunity to design your classes in a heirarchical way , whereby you can have one class \u0026ldquo;inherit\u0026rdquo; from or borrow attributes that is metods or variables from another class if they are all have those in common.\nTryign this concept: wizard.py # class Wizard: def __init__(self, name): if not name: raise ValueError(\u0026#34;Missing name\u0026#34;) self.name = name ... class Student(Wizard): def __init__(self, name, house): super().__init__(name) # Super have the habilitiy to call the constructor of the parent class self.house = house ... class Professor(Wizard): def __init__(self, name, subject): super().__init__(name) self.subject = subject ... wizard = Wizard(\u0026#34;Albus\u0026#34;) student = Student(\u0026#34;Harry\u0026#34;, \u0026#34;Gryffindor\u0026#34;) professor = Professor(\u0026#34;Severus\u0026#34;, \u0026#34;Defense Against the Dark Arts\u0026#34;) Exceptions hierarchy # BaseException +-- KeyboardInterrupt +-- Exception +-- ArithmeticError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- KeyError +-- NameError +-- SyntaxError | +-- IndentationError +-- ValueError Operator Overloading: vault.py # Operator overloading is a specific case of polymorphism, where different operators have different implementations depending on their arguments.\nIn other words, a + doesn\u0026rsquo;t always mean addition, it can mean concatenation if the operands are strings for example.\nDocumentation\n__add__ is a special method that is called when the + operator is used. class Vault: def __init__(self, galleons=0, sickles=0, knuts=0): self.galleons = galleons self.sickles = sickles self.knuts = knuts def __str__(self): return f\u0026#34;{self.galleons} galleons, {self.sickles} sickles, {self.knuts} knuts\u0026#34; def __add__(self, other): galleons = self.galleons + other.galleons sickles = self.sickles + other.sickles knuts = self.knuts + other.knuts return Vault(galleons, sickles, knuts) potter = Vault(100, 50, 25) print(potter) weasley = Vault(25, 50, 100) print(weasley) total = Vault(galleons, sickles, knuts) print(total) ","date":"3 agosto 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_8/","section":"Projects","summary":"This week outlines the principles of OOP, including classes, objects, and inheritance, emphasizing how these concepts facilitate code organization and reuse.","title":"Week 8: Object-Oriented Programming","type":"projects"},{"content":" Regular Expressions # Know as a regex is just a pattern that we can use to match strings. It is a powerful tool that allows us to search for strings that match a certain pattern.\nValidation with Regular Expressions # email = input(\u0026#34;Whats your email? \u0026#34;).strip() username, domain = email.split(\u0026#34;@\u0026#34;) if username and domain.ends with(\u0026#34;.edu\u0026#34;): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) re Library # This library let us define a pattern that we can use to match strings.\nDocumentation\nre.search(pattern, string, flags=0) import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(\u0026#34;@\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Regular Expressions Patterns # Symbols # Symbol Description . Matches any character except a newline. ^ Matches the start of the string. $ Matches the end of the string. * Matches 0 or more repetitions of the preceding pattern. + Matches 1 or more repetitions of the preceding pattern. ? Matches 0 or 1 repetition of the preceding pattern. {n} Matches exactly n repetitions of the preceding pattern. {n,} Matches n or more repetitions of the preceding pattern. {n,m} Matches between n and m repetitions of the preceding pattern. [] Matches any one of the characters inside the brackets. [^] Matches any character not inside the brackets. ` ` () Groups patterns and captures the matched text. (?:...) Groups patterns without capturing the matched text. \\ Escapes special characters or denotes a special sequence. \\d Matches any digit; equivalent to [0-9]. \\D Matches any non-digit; equivalent to [^0-9]. \\w Matches any word character (alphanumeric plus underscore); equivalent to [a-zA-Z0-9_]. \\W Matches any non-word character; equivalent to [^a-zA-Z0-9_]. \\s Matches any whitespace character (spaces, tabs, newlines). \\S Matches any non-whitespace character. \\b Matches a word boundary. \\B Matches a non-word boundary. Code using Regular Expression Patterns # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;.+@.+\\.edu\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Matching Start and End # ^ Matches the start of the string. $ Matches the end of the string. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^.+@.+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Sets of Characters # [] Matches any one of the characters inside the brackets. [^] Matches any character not inside the brackets. 1. [^@]+ # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^[^@]+@[^@]+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) 2. [a-zA-Z0-9_]+ # import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Character Classes # \\d Matches any digit; equivalent to [0-9]. \\D Matches any non-digit; equivalent to [^0-9]. /s Matches any whitespace character (spaces, tabs, newlines). \\S Matches any non-whitespace character. \\w Matches any word character (alphanumeric plus underscore); equivalent to [a-zA-Z0-9_]. \\W Matches any non-word character; equivalent to [^a-zA-Z0-9_]. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^\\w+@\\w+\\.edu$\u0026#34;, email): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Flags # re.IGNORECASE Makes the pattern case-insensitive. re.MULTILINE Makes the pattern match the start and end of each line. re.DOTALL Makes the . character match any character, including newlines. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^\\w+@\\w+\\.edu$\u0026#34;, email, re.IGNORECASE): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Groups # A|B Matches either the pattern before or the pattern after the pipe. () Groups patterns and captures the matched text. (?:...) Groups patterns without capturing the matched text. import re email = input(\u0026#34;Whats your email? \u0026#34;).strip() if re.search(r\u0026#34;^(\\w|\\.)+@(\\w+\\.)?\\w+\\.edu$\u0026#34;, email, re.IGNORECASE): print(\u0026#34;Valid\u0026#34;) else: print(\u0026#34;Invalid\u0026#34;) Email Address Validation # This is the regular expression pattern that the browsers uses to validate email addresses.\n^[a-zA-Z0-9.!#$%\u0026amp;\u0026#39;*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ match, fullmatch # re.match(pattern, string, flags=0) Matches the pattern at the start of the string. re.fullmatch(pattern, string, flags=0) Matches the pattern against the whole string. Capturing Groups # When we use () we are creating a capturing group that allows us to extract the matched text. := is the walrus operator that allows us to assign a value to a variable and use it in the same line. import re name = input(\u0026#34;Whats your name? \u0026#34;).strip() if matches := re.search(r\u0026#34;^(.+), *(.+)$\u0026#34;, name): name = matches.group(2) + \u0026#34; \u0026#34; + matches.group(1) print(f\u0026#34;Hello, {name}\u0026#34;) Extracting from Strings # 1. re.sub # .re.sub(pattern, repl, string, count=0, flags=0) Replaces the matched text with the replacement text. import re url = input(\u0026#34;URL: \u0026#34;).strip() username = re.sub(r\u0026#34;^(https?://)?(www\\.)?twitter\\.com/\u0026#34;, \u0026#34;\u0026#34;, url) print(f\u0026#34;Username: {username}\u0026#34;) 2. re.search # re.search(pattern, string, flags=0) Searches for the pattern in the string. import re url = input(\u0026#34;URL: \u0026#34;).strip() if matches := re.search(r\u0026#34;^https?://?(?:www\\.)?twitter\\.com/([a-z0-9_]+)\u0026#34;, url, re.IGNORECASE) print(f\u0026#34;Username: {matches.group(1)}\u0026#34;) Conclusion # There are other other functions\nre.split(pattern, string, maxsplit=0, flags=0) Splits the string at the matches of the pattern. re.findall(pattern, string, flags=0) Finds all the matches of the pattern in the string. ","date":"26 julio 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_7/","section":"Projects","summary":"This week explores regular expressions as powerful tools for string matching and validation, detailing how to use them effectively within Python programs.","title":"Week 7: Regular Expressions","type":"projects"},{"content":" File I/O # File I/O (input/output) is a way to read and write data to and from files. This is useful for saving data to a file, or reading data from a file.\nlists # Usually the data is stored in a list but the moment the program is closed, the data is lost. This is where file I/O comes in. It allows you to save the data to a file, and read it back in when the program is run again.\nCode example of storing data in a list # names = [] for _ in range(3): names.append(input(\u0026#34;What\u0026#39;s your name? \u0026#34;)) for name in sorted(names): print(f\u0026#34;hello, {name}\u0026#34;) open # The open function is used to open a file. It takes two arguments, the name of the file, and the mode to open the file in. The mode can be r for read, w for write, or a for append.\nDocumentation\nCode example of opening a file in write mode # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) file = open(\u0026#34;names.txt\u0026#34;, \u0026#34;w\u0026#34;) file.write(name) file.close() Code example of opening a file in append mode # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) file = open(\u0026#34;names.txt\u0026#34;, \u0026#34;a\u0026#34;) file.write(f\u0026#34;{name}\\n\u0026#34;) file.close() with # The with statement is used to open a file and automatically close it when the block is done. This is useful because it ensures that the file is closed, even if an error occurs.\nDocumentation\nCode example of using the with statement # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) with open(\u0026#34;names.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(f\u0026#34;{name}\\n\u0026#34;) Reading from a file # To read from a file, you can use the read method to read the entire file, or the readline method to read one line at a time.\nThe value returned by the read method is a string, while the value returned by the readline method is a list of strings.\nDocumentation\nCode example of reading from a file # with open(\u0026#34;names.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(\u0026#34;hello,\u0026#34;, line.rstrip()) sorted # The sorted function is used to sort a list. It takes a list as an argument, and returns a new list with the elements sorted.\nDocumentation\n1. Code example of sorting a list (straightforward code) # names - [] \u0026#39;\u0026#39;\u0026#39; When you want to open a file in read mode you don\u0026#39;t need to specify the mode because it is the default mode. \u0026#39;\u0026#39;\u0026#39; with open (\u0026#34;names.txt\u0026#34;) as file: for line in file: names.append(line.rstrip()) for name in sorted(names): print(f\u0026#34;hello, {name}\u0026#34;) 2. Code example of sorting a list (tighter code) # with open(\u0026#34;names.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in sorted(file): print(\u0026#34;hello,\u0026#34;, line.rstrip()) Comma-Separated Values (CSV) # Comma-Separated Values (CSV) is a file format used to store tabular data. Each line in the file represents a row in the table, and the values are separated by commas.\nThe csv module in Python can be used to read and write CSV files.\nDocumentation\nCSV file example # Hermione,Gryffindor Harry,Gryffindor Ron,Gryffindor Draco,Slytherin 1. Code example of reading from a CSV file without the csv module # with open(sudents.csv) as file: for line in file: row = line.rstrip().split(\u0026#34;,\u0026#34;) print(f\u0026#34;{row[0]} is in {row[1]}\u0026#34;) 2. Code example of reading from a CSV file without the csv module and using dictionaries # students = [] with open(sudents.csv) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) for student in students: print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) Sort keys # The sorted function can take a key argument to specify a function to use to extract a comparison key from each element in the list.\nDocumentation\nCode example of sorting a list of dictionaries by a key # students = [] with open(\u0026#34;students.csv\u0026#34;) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) def get_name(student): return student[\u0026#34;name\u0026#34;] for student in sorted(students, key=get_name): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) Lambda functions # Lambda functions are small anonymous functions that can have any number of arguments, but only one expression.\nDocumentation\nCode example of using a lambda function # students = [] with open(\u0026#34;students.csv\u0026#34;) as file: for line in file: name, house = line.rstrip().split(\u0026#34;,\u0026#34;) student = {\u0026#34;name\u0026#34;: name, \u0026#34;house\u0026#34;: house} students.append(student) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is in {student[\u0026#39;house\u0026#39;]}\u0026#34;) New CSV file example # Harry,Number Four, Privet Drive Ron,The Burrow Draco,Malfoy Manor CSV Library # The csv module in Python can be used to read and write CSV files. It provides a DictReader class to read CSV files as dictionaries, and a DictWriter class to write dictionaries to CSV files.\nDocumentation\nCode example of reading from a CSV file using the csv module: reader # import csv students = [] with open(\u0026#34;students.csv\u0026#34;) as file: reader = csv.reader(file) for name, home in reader: students.append({\u0026#34;name\u0026#34;: name, \u0026#34;home\u0026#34;: home}) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is from {student[\u0026#39;home\u0026#39;]}\u0026#34;) Code example of reading from a CSV file using the csv module: DictReader # New CSV file example # name,home Harry,Number Four, Privet Drive Ron,The Burrow Draco,Malfoy Manor Code # import csv students = [] with open(\u0026#34;students.csv\u0026#34;) as file: reader = csv.DictReader(file) for row in reader: sudents.append({\u0026#34;name\u0026#34;: row[\u0026#34;name\u0026#34;], \u0026#34;home\u0026#34;: row[\u0026#34;home\u0026#34;]}) for student in sorted(students, key=lambda student: student[\u0026#34;name\u0026#34;]): print(f\u0026#34;{student[\u0026#39;name\u0026#39;]} is from {student[\u0026#39;home\u0026#39;]}\u0026#34;) Code example of writing to a CSV file using the csv module: writer # In the CSV file # name,home Code # import csv name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) home = input(\u0026#34;Where\u0026#39;s your home? \u0026#34;) with open(\u0026#34;students.csv\u0026#34;, \u0026#34;a\u0026#34;) as file: writer = csv.writer(file) writer.writerow([name, home]) Code example of writing to a CSV file using the csv module: DictWriter # Code # import csv name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) home = input(\u0026#34;Where\u0026#39;s your home? \u0026#34;) with open(\u0026#34;students.csv\u0026#34;, \u0026#34;a\u0026#34;) as file: writer = csv.DictWriter(file, fieldnames=[\u0026#34;name\u0026#34;, \u0026#34;home\u0026#34;]) writer.writeheader() # This didn\u0026#39;t appear in the video but is necessary to write the header writer.writerow({\u0026#34;name\u0026#34;: name, \u0026#34;home\u0026#34;: home}) Images, PIL library # The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. This library supports many file formats, and provides powerful image processing and graphics capabilities.\nDocumentation\nCode example of creating a simple gif # import sys from PIL import Image images = [] for arg in sys.argv[1:]: image = Image.open(arg) images.append(image) images[0].save( \u0026#34;costumes.gif\u0026#34;, save_all=True, append_images=[images[1]], duration=200, loop=0 ) ","date":"20 julio 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_6/","section":"Projects","summary":"This week covers file input/output operations, explaining how to read and write data, manage file formats like CSV, and manipulate data structures such as lists and dictionaries.","title":"Week 6: File I/O","type":"projects"},{"content":" Unit Tests # Is a way to test the code you wrote.\nTesting calculator.py # Calculator.py code # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(\u0026#34;x squared is\u0026#34;, square(x)) def square(n): return n * n if __name__ == \u0026#34;__main__\u0026#34;: main() test_calculator.py code # from calculator import square def main(): test_square() def test_square(): if square(2) != 4: print(\u0026#34;2 squared is not 4\u0026#34;) if square(3) != 9: print(\u0026#34;3 squared is not 9\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() assert # testing this code\ndef main(): test_square() def test_square(): assert square(2) == 4 assert square(3) == 9 if __name__ == \u0026#34;__main__\u0026#34;: main() AssertionError # How to handle an AssertionError\nFirst \u0026ldquo;bad\u0026rdquo; try # testing this code\ndef main(): test_square() def test_square(): try: assert square(2) == 4 except AssertionError: print(\u0026#34;2 squared is not 4\u0026#34;) try: assert square(3) == 9 except AssertionError: print(\u0026#34;3 squared is not 9\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Second \u0026ldquo;bad\u0026rdquo; try with more examples # testing this code\ndef main(): test_square() def test_square(): try: assert square(2) == 4 except AssertionError: print(\u0026#34;2 squared is not 4\u0026#34;) try: assert square(3) == 9 except AssertionError: print(\u0026#34;3 squared is not 9\u0026#34;) try: assert square(-3) == 9 except AssertionError: print(\u0026#34;-3 squared is not 9\u0026#34;) try: assert square(0) == 0 except AssertionError: print(\u0026#34;0 squared is not 0\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() pytest # Installation # $ pip install pytest Documentation # pytest documentation\nSame test with pytest and all the tests in one function # testing this code\nfrom calculator import square def test_square(): assert square(2) == 4 assert square(3) == 9 assert square(-2) == 4 assert square(-3) == 9 assert square(0) == 0 And then run the test with pytest test_calculator.py\n$ pytest test_calculator.py Categories of tests # testing this code\nfrom calculator import square def test_positive(): assert square(2) == 4 assert square(3) == 9 def test_negative(): assert square(-2) == 4 assert square(-3) == 9 def test_zero(): assert square(0) == 0 Testing for exceptions # testing this code\nimport pytest from calculator import square def test_positive(): assert square(2) == 4 assert square(3) == 9 def test_negative(): assert square(-2) == 4 assert square(-3) == 9 def test_zero(): assert square(0) == 0 def test_str(): with pytest.raises(TypeError): square(\u0026#34;cat\u0026#34;) Side Effects and Testing # hello.py code # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) hello(name) def hello(to=\u0026#34;world\u0026#34;): print(f\u0026#34;hello, \u0026#34;, to) if __name__ == \u0026#34;__main__\u0026#34;: main() test_hello.py code # testing this code\nfrom hello import hello def test_arguement(): assert hello(\u0026#34;David\u0026#34;) == \u0026#34;hello, David\u0026#34; The test will fail because the function hello prints the message instead of returning it.\nPrinting the message is a side effect.\nIs a good practice to avoid side effects in functions as much as possible so the function can be tested.\nNew testable version of hello.py # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) print(hello(name)) def hello(to=\u0026#34;world\u0026#34;): return f\u0026#34;hello, {to}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: main() This is a better version because the assert tests are meant to check the return value of the function and not the side effects. test_hello.py code # testing this code\nfrom hello import hello def test_default(): assert hello() == \u0026#34;hello, world\u0026#34; def test_arguement(): for name in [\u0026#34;Hermione\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;]: assert hello(name) == f\u0026#34;hello, {name}\u0026#34; Collections of tests # With a structure like this:\nproject/ hello.py test/ __init__.py test_hello.py test_hello.py code # from hello import hello def test_default(): assert hello() == \u0026#34;hello, world\u0026#34; def test_arguement(): assert hello(\u0026#34;David\u0026#34;) == \u0026#34;hello, David\u0026#34; init.py # Even if it\u0026rsquo;s empty, __init__.py have the effect of telling Python that the directory is not just a module, but a package.\nRunning the tests # $ pytest test ","date":"14 julio 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_5/","section":"Projects","summary":"This week highlights the importance of testing in software development, discussing unit tests and the use of frameworks like pytest to ensure code quality and reliability.","title":"Week 5: Unit Tests","type":"projects"},{"content":" Libraries # A piece of code that someone else wrote that you can use in your code.\nModules # Is a library that has one or more functions built into it.\nRe-usability code.\nrandom # random is a built-in module in Python. It has a set of functions to generate random numbers.\nDocumentation\nimport # To use a module, you have to import it.\nimport random coin = random.choice([\u0026#34;head\u0026#34;, \u0026#34;tails\u0026#34;]) print(coin) from # Is the keyword to import a specific function from a module.\nfrom random import choice coin = choice([\u0026#34;head\u0026#34;, \u0026#34;tails\u0026#34;]) print(coin) randint, shuffle # randint # import random number = random.randint(1, 10) print(number) shuffle # import random cards = [\u0026#34;jack\u0026#34;, \u0026#34;queen\u0026#34;, \u0026#34;king\u0026#34;] random.shuffle(cards) for card in cards: print(card) statistics # statistics is a built-in module in Python. It has a set of functions to calculate statistics.\nDocumentation\nimport statistics print(statistics.mean([100, 90])) Command-line Arguments, sys # sys module, provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.\nDocumentation\nsys.argv: argument vector, a list of strings representing the arguments. import sys if len(sys.argv) \u0026lt; 2: print(\u0026#34;Too few arguments\u0026#34;) elif len(sys.argv) \u0026gt; 2: print(\u0026#34;Too many arguments\u0026#34;) else: print(\u0026#34;hello, my name is\u0026#34;, sys.argv[1]) sys.exit # Exit from Python.\nimport sys if len(sys.argv) \u0026lt; 2: sys.exit(\u0026#34;Too few arguments\u0026#34;) elif len(sys.argv) \u0026gt; 2: print(\u0026#34;Too many arguments\u0026#34;) print(\u0026#34;hello, my name is\u0026#34;, sys.argv[1]) slices # A slice is a portion of a list.\nimport sys if len(sys.argv) \u0026lt; 2: sys.exit(\u0026#34;Too few arguments\u0026#34;) for arg in sys.argv[1:]: print(\u0026#34;hello, my name is\u0026#34;, arg) Packages, PyPI, pip # Package: is a collection of modules. PyPI: Python Package Index, is a repository of software for the Python programming language. pip: is a package installer for Python. cowsay # Documentation\nInstall # pip install cowsay Usage # import cowsay import sys if len(sys.arg) == 2: cowsay.cow(\u0026#34;hello, \u0026#34; + sys.argv[1]) APIs, requests, JSON # API: Application Programming Interface. requests: is a simple HTTP library for Python. JSON: JavaScript Object Notation, a language-independent data format. Pretty print JSON # import json import requests import sys if len(sys.argv) != 2: sys.exit() response = requests.get(\u0026#34;https://itunes.apple.com/search?entity=song\u0026amp;limit=1\u0026amp;term=\u0026#34; + sys.argv[1]) print(json.dumps(response.json(), indent=2)) Printing the track name from the API # import json import requests import sys if len(sys.argv) != 2: sys.exit() response = requests.get(\u0026#34;https://itunes.apple.com/search?entity=song\u0026amp;limit=50\u0026amp;term=\u0026#34; + sys.argv[1]) o = response.json() for result in o[\u0026#34;results\u0026#34;]: print(result[\u0026#34;trackName\u0026#34;]) Custom Libraries # Create your own library.\nsayings.py # def main(): hello(\u0026#34;world\u0026#34;) goodbye(\u0026#34;world\u0026#34;) def hello(name): print(f\u0026#34;hello, {name}\u0026#34;) def goodbye(name): print(f\u0026#34;goodbye, {name}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() say.py # import sys from sayings import hello if len(sys.argv) == 2: hello(sys.argv[1]) ","date":"13 julio 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_4/","section":"Projects","summary":"This week introduces the concept of libraries and modules in Python, explaining how to import and use them, along with mentioning popular libraries for statistical analysis and file handling.","title":"Week 4: Libraries","type":"projects"},{"content":" Exceptions # That means that something went wrong in the program. It is an error that happens during the execution of the program.\nSyntax Error # This is just and introductory example. The error is in the syntax of the code. It is a mistake in the code that the python interpreter can not execute.\nprint(\u0026#34;Hello World) This error is a error that you need to fix, you can\u0026rsquo;t create a code to handle this error.\nValueError # This error happens when you try to convert a string to a number, but the string is not a number.\nx = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(f\u0026#34;x is {x}\u0026#34;) This programs works fine if you input a number, but if you input a string, it will raise a ValueError.\ntry, except # You can handle exceptions with the try and except blocks.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(f\u0026#34;x is {x}\u0026#34;) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) NameError # This error happens when you try to use a variable that is not defined.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) print(f\u0026#34;x is {x}\u0026#34;) else # You can use the else block to run a code if the try block does not raise an exception.\ntry: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) else: print(f\u0026#34;x is {x}\u0026#34;) Reprompting, break # You can use a while loop to reprompt the user if the input is not valid.\nwhile True: try: x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) else: break print(f\u0026#34;x is {x}\u0026#34;) get_int # You can create a function to get an integer from the user.\ndef main(): x = get_int() print(f\u0026#34;x is {x}\u0026#34;) def get_int(): while True: try: return x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: print(\u0026#34;x is not an integer\u0026#34;) main() pass # You can use the pass statement to do nothing.\ndef main(): x = get_int() print(f\u0026#34;x is {x}\u0026#34;) def get_int(): while True: try: return x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) except ValueError: pass main() Note: In this case I wouln\u0026rsquo;t use the pass argument, I think as a user would be weird to just be asked again and again for the same input.\nfunction arguments # This is a refined version of the get_int function.\ndef main(): x = get_int(\u0026#34;What\u0026#39;s x? \u0026#34;) print(f\u0026#34;x is {x}\u0026#34;) def get_int(prompt): while True: try: return x = int(input(prompt)) except ValueError: pass main() raise # This was just a quick mention of the raise statement.\n","date":"10 julio 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_3/","section":"Projects","summary":"This week focuses on error management in Python, detailing different types of exceptions and methods to handle them, ensuring robust and error-free code execution.","title":"Week 3: Exceptions","type":"projects"},{"content":" Loops # The ability of doing something multiple times cat.py # Example of code # print(\u0026#34;meow\u0026#34;) print(\u0026#34;meow\u0026#34;) print(\u0026#34;meow\u0026#34;) Flowchart of the code # while # Is a way to repeat a block of code while a condition is true While using substraction # i = 3 while i != 0: print(\u0026#34;meow\u0026#34;) i = i - 1 Flowchart of the code # While using addition # i = 0 while i \u0026lt; 3: print(\u0026#34;meow\u0026#34;) i = i + 1 Flowchart of the code # for # Is a way to repeat a block of code a number of times For using a list # for i in [0, 1, 2]: print(\u0026#34;meow\u0026#34;) For using range # for i in range(3): print(\u0026#34;meow\u0026#34;) Pythonic way v1 # The _ is a convention to indicate that the variable is not going to be used or is not important for _ in range(3): print(\u0026#34;meow\u0026#34;) Pythonic way v2 # print(\u0026#34;meow\\n\u0026#34; * 3, end=\u0026#34;\u0026#34;) Validating input # Is a way to ensure that the input is correct Example of code # while True: n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) if n \u0026gt; 0: break for _ in range(n): print(\u0026#34;meow\u0026#34;) Exampo of code using a function # def main(): number = get_number() meow(number) def get_number(): while True: n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) if n \u0026gt; 0: return n def meow(n): for _ in range(n): print(\u0026#34;meow\u0026#34;) main() Iteration with Lists # Is a way to iterate over a list Example of code # students = \u0026#34;[Hermione, Harry, Ron]\u0026#34; for student in students: print(student) len # Is a way to get the length of a list Example of code # students = [\u0026#34;Hermione\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Ron\u0026#34;] for i in range(len(students)): print(i + 1, students[i]) Dictionaries # Is a way to store key-value pairs Example of the code in a manual way # students = { \u0026#34;Hermione\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Harry\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Ron\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Draco\u0026#34;: \u0026#34;Slytherin\u0026#34;, } print(students[\u0026#34;Hermione\u0026#34;]) print(students[\u0026#34;Harry\u0026#34;]) print(students[\u0026#34;Ron\u0026#34;]) print(students[\u0026#34;Draco\u0026#34;]) Example of the code using a loop # students = { \u0026#34;Hermione\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Harry\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Ron\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;Draco\u0026#34;: \u0026#34;Slytherin\u0026#34;, } for student in students: print(student, students[student], sep=\u0026#34;, \u0026#34;) List of Dictionaries # students = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Otter\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Stag\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Jack Russell terrier\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;, \u0026#34;patronus\u0026#34;: None}, ] for student in students: print(student[\u0026#34;name\u0026#34;], student[\u0026#34;house\u0026#34;], student[\u0026#34;patronus\u0026#34;], sep=\u0026#34;, \u0026#34;) Nested Loops # Is a way to have a loop inside another loop Example of code v1 # def main(): print_square(3) def print_square(size): # For each row in square for _ in range(size): # For each brick in row for _ in range(size): # Print brick print(\u0026#34;#\u0026#34;, end=\u0026#34;\u0026#34;) print() main() Example of code v2 # def main(): print_square(3) def print_square(size): for i in range(size): for j in range(size): print(\u0026#34;#\u0026#34;, end=\u0026#34;\u0026#34;) print() main() Example of code v3 # def main(): print_square(3) def print_square(size): for _ in range(size): print(\u0026#34;#\u0026#34; * size) main() Example of code v4 # def main(): print_square(3) def print_square(size): for _ in range(size): print_row(size) def print_row(width): print(\u0026#34;#\u0026#34; * width) main() Expected output for all examples # ### ### ### ","date":"9 mayo 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_2/","section":"Projects","summary":"This week focuses on loops in programming, detailing how to iterate over data structures using for and while loops, and discussing concepts such as nested loops and list iteration.","title":"Week 2: Loops","type":"projects"},{"content":" Conditionals # Ability to ask and answer questions Comparison Operators in Python # Symbol Meaning \u0026gt; Greater than \u0026lt; Less than == Equal to != Not equal to \u0026gt;= Greater than or equal to \u0026lt;= Less than or equal to if # Example of a code using if # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) if x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) if x == y: print(\u0026#34;x is equal to y\u0026#34;) In this example \u0026ldquo;x \u0026lt; y\u0026rdquo; is a boolean expression Flowchart of the code # elif # Example of a code using elif # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) elif x == y: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # else # Example of a code using else # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # or # Example of a code using or # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x \u0026lt; y or x \u0026gt; y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # Not Equal # Example of a code using not equal # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x != y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;) Flowchart of the code # Example of a code using equal # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if x == y: print(\u0026#34;x is equal to y\u0026#34;) else: print(\u0026#34;x is not equal to y\u0026#34;) Flowchart of the code # Identation, Colons # Identation is important in Python, if you don\u0026rsquo;t use it, you will get an error\nThe colon is also important, it tells Python that the next line is going to be a block of code\nand # Example of a code using and # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90 and score \u0026lt;= 100: print(\u0026#34;Grade: A\u0026#34;) elif score \u0026gt;= 80 and score \u0026lt; 90: print(\u0026#34;Grade: B\u0026#34;) elif score \u0026gt;= 70 and score \u0026lt; 80: print(\u0026#34;Grade: C\u0026#34;) elif score \u0026gt;= 60 and score \u0026lt; 70: print(\u0026#34;Grade: D\u0026#34;) else: print(\u0026#34;Grade: F\u0026#34;) Chaining Comparison Operators # Example of a code using chaining comparison operators # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90: print(\u0026#34;Grade: A\u0026#34;) elif score \u0026gt;= 80: print(\u0026#34;Grade: B\u0026#34;) elif score \u0026gt;= 70: print(\u0026#34;Grade: C\u0026#34;) elif score \u0026gt;= 60: print(\u0026#34;Grade: D\u0026#34;) else: print(\u0026#34;Grade: F\u0026#34;) Bugs # Example of a code with a bug: using if instead of elif # score = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90: print(\u0026#34;Grade: A\u0026#34;) if score \u0026gt;= 80: print(\u0026#34;Grade: B\u0026#34;) if score \u0026gt;= 70: print(\u0026#34;Grade: C\u0026#34;) if score \u0026gt;= 60: print(\u0026#34;Grade: D\u0026#34;) Modulo # Some remaining operators # Symbol Meaning + Addition - Subtraction * Multiplication / Division % Modulo (Remainder) Example of a code using modulo # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) if x % 2 == 0: print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) Boolean # Example of a code using boolean # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if is_even(x): print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) def is_even(n): if n % 2 == 0: return True else: return False main() Pythonic Expressions # Example of a code using Pythonic Expressions # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) if is_even(x): print(\u0026#34;x is Even\u0026#34;) else: print(\u0026#34;x is Odd\u0026#34;) def is_even(n): return n % 2 == 0 main() match # Example of a code using match # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) match name: case \u0026#34;Harry\u0026#34; | \u0026#34;Herminone\u0026#34; | \u0026#34;Ron\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) case \u0026#34;Draco:\u0026#34;: print(\u0026#34;Slytherin\u0026#34;) case _: print(\u0026#34;Who?\u0026#34;) ","date":"24 abril 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_1/","section":"Projects","summary":"This week discusses control flow elements like conditionals and logical operators, which are essential for making decisions in code and controlling how it executes.","title":"Week 1: Conditionals","type":"projects"},{"content":" CS50’s Introduction to Programming with Python # Github repository # Here you can check the Github repository used trough the course.\nCertificate # Here you can see my certificate of the course.\nWeek 0: Functions, Variables # This week covers fundamental programming concepts including functions, data types, and debugging techniques, providing a foundational understanding for writing and troubleshooting code.\nKey concepts Concept Details Functions A block of code that performs a specific task. Bugs and Debugging Mistakes in the code and how to fix them. Data Types The type of data that a variable can store. Named Parameters Parameters that are passed by name. String Methods Methods that can be used with strings. Integers and Operators Operators that can be used with integers. Type Conversion Converting one data type to another. Week 1: Conditionals # This week discusses control flow elements like conditionals and logical operators, which are essential for making decisions in code and controlling how it executes.\nKey concepts Concept Details Comparison Operators Operators that compare two values. if A way to run code conditionally. elif A way to run code conditionally if the first condition is false. else A way to run code if all other conditions are false. or A way to combine conditions. not equal A way to check if two values are not equal. and A way to combine conditions. chains A way to combine multiple conditions. modulo A way to get the remainder of a division. boolean A way to represent true or false values. pythonic expressions A way to write code in a more concise way. match A way to match a value to a pattern. Week 2: Loops # This week focuses on loops in programming, detailing how to iterate over data structures using for and while loops, and discussing concepts such as nested loops and list iteration.\nKey concepts Concept Details Loops The ability of doing something multiple times. while A way to repeat a block of code while a condition is true. for A way to repeat a block of code a number of times. Validating input A way to ensure that the input is correct. Iteration with Lists A way to iterate over a list. len A way to get the length of a list. Dictionaries A way to store key-value pairs. List of Dictionaries A way to store a list of dictionaries. Nested Loops A way to have a loop inside another loop. Week 3: Exceptions # This week focuses on error management in Python, detailing different types of exceptions and methods to handle them, ensuring robust and error-free code execution.\nKey concepts Concept Details Exceptions A way to handle errors in the code. Syntax Error A mistake in the code that the Python interpreter cannot execute. ValueError An error that happens when you try to convert a string to a number, but the string is not a number. try, except A way to handle exceptions. NameError An error that happens when you try to use a variable that is not defined. else A way to run code if the try block does not raise an exception. Reprompting, break A way to reprompt the user if the input is not valid. get_int A way to create a function to get an integer from the user. pass A way to do nothing. function arguments A way to pass arguments to a function. raise A way to raise an exception. Week 4: Libraries # This week introduces the concept of libraries and modules in Python, explaining how to import and use them, along with mentioning popular libraries for statistical analysis and file handling.\nKey concepts Concept Details Libraries A piece of code that someone else wrote that you can use in your code. Modules A library that has one or more functions built into it. import To use a module, you have to import it. from The keyword to import a specific function from a module. statistics A built-in module in Python that has a set of functions to calculate statistics. Command-line Arguments, sys The sys module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. Packages, PyPI, pip Package: A collection of modules. PyPI: Python Package Index, a repository of software for Python. pip: a package installer for Python. Custom Libraries Create your own library. Week 5: Unit Tests # This week highlights the importance of testing in software development, discussing unit tests and the use of frameworks like pytest to ensure code quality and reliability.\nKey concepts Concept Details Unit Tests A way to test the code you wrote. assert A way to test the code you wrote. AssertionError A way to handle an AssertionError. pytest A testing framework that makes it easy to write small tests. Side Effects and Testing A way to test the code you wrote. Collection of Tests A way to group tests together. Week 6: File I/O # This week covers file input/output operations, explaining how to read and write data, manage file formats like CSV, and manipulate data structures such as lists and dictionaries.\nKey concepts Concept Details File I/O A way to read and write data to and from files. lists Data is stored in a list, but the moment the program is closed, the data is lost. open Used to open a file. with Used to open a file and automatically close it when the block is done. Reading from a file Use the read method to read the entire file, or readline to read one line at a time. sorted Used to sort a list. Comma-Separated Values (CSV) A file format used to store tabular data. sort keys Used to sort a list of dictionaries by a key. Lambda Functions A way to create small anonymous functions. CSV Library A library that can be used to read and write CSV files. Images, PIL Library A library that can be used to read and write images. Week 7: Regular Expressions # This week explores regular expressions as powerful tools for string matching and validation, detailing how to use them effectively within Python programs.\nKey concepts Concept Details Regular Expressions A pattern that we can use to match strings. Validation with Regular Expressions A way to validate strings using regular expressions. re Library A library that allows us to define a pattern to match strings. Regular Expressions Patterns A set of symbols that can be used to match strings. Week 8: Object-Oriented Programming # This week outlines the principles of OOP, including classes, objects, and inheritance, emphasizing how these concepts facilitate code organization and reuse.\nKey concepts Concept Details Object-Oriented Programming (OOP) A programming paradigm that uses \u0026ldquo;objects\u0026rdquo; to design applications and computer programs. Tuples A collection of objects that are ordered and immutable. Dictionaries A collection of key-value pairs that is more powerful than a list. Classes and Objects A class is a blueprint or a mold for creating objects. Instance Methods Functions defined inside a class used to perform operations on objects of that class. Types and Classes A type is a category of values, and a class is a blueprint for creating objects. Class methods Methods that are bound to the class and not the object of the class. Static methods Methods that are bound to the class and not the object of the class. Inheritance A way to create a new class that is based on an existing class. Operator Overloading A way to define how an operator behaves when used with a class. Week 9: Et Cetera # This week presents advanced programming features like sets, global variables, type hints, and comprehensions, enhancing Python’s functionality and readability while promoting best practices.\nKey concepts Concept Details set A collection of unique elements; an unordered collection of items. global Used to declare that a variable inside the function is global (outside the function). constants A type of variable whose value cannot be changed. Type Hints, mypy A static type checker for Python. Docstrings A string that appears right after the definition of a function, class, or module. argparse A module in the Python standard library that allows you to parse command-line arguments. unpacking A way to assign the elements of an iterable to multiple variables. map A function that applies a given function to each item of an iterable (list, tuple, etc.). List Comprehensions A way to create lists in Python. filter A function that filters elements of an iterable based on a given function. Dictionary Comprehensions A way to create dictionaries in Python. enumerate A function that adds a counter to an iterable. Generators, Iterators A way to create iterators in Python. Weeks in detail # ","date":"14 agosto 2024","externalUrl":null,"permalink":"/projects/cs50-python/","section":"Projects","summary":"Here you will find a short summary of the key concepts of each week of the CS50P course in addition to the posts on the detailed notes of each week.","title":"CS50-Python certification","type":"projects"},{"content":" Hello Bison in Python # print(\u0026#34;Hello Bison!\u0026#34;) Functions # We just used the print function.\nArgument: value passed to a function.\nSide effects: printing to the console.\nBugs and Debugging # Bugs: mistakes in the code.\nDebugging: finding and fixing bugs.\nReturn values and Variables # Return values: values returned by functions.\nVariables: store values for later use.\nComments and Pseudocode # Comments: notes to self and others.\nPseudocode: planning code before writing it.\nMultiple function arguments # String: a sequence of characters.\nConcateation: combining strings.\nTable of Data Types # Data Type Description int Integer numbers (e.g., 5, -3, 100) float Floating point numbers (e.g., 3.14, -0.001, 2.0) complex Complex numbers (e.g., 3 + 4j, -2.5 + 0.1j) str String (e.g., \u0026ldquo;hello\u0026rdquo;, \u0026lsquo;world\u0026rsquo;, \u0026ldquo;123\u0026rdquo;) list List (e.g., [1, 2, 3], [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]) tuple Tuple (e.g., (1, 2, 3), (\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;)) set Set (e.g., {1, 2, 3}, {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;}) dict Dictionary (e.g., {\u0026lsquo;key\u0026rsquo;: \u0026lsquo;value\u0026rsquo;}, {1: \u0026lsquo;one\u0026rsquo;, 2: \u0026rsquo;two\u0026rsquo;}) bool Boolean (True or False) bytes Immutable bytes sequence (e.g., b\u0026rsquo;hello\u0026rsquo;, b\u0026rsquo;\\x00\\x01\\x02\u0026rsquo;) Named Parameters # Documentation for print function # print(*objects, sep=\u0026#39; \u0026#39;, end=\u0026#39;\\n\u0026#39;, file=sys.stdout, flush=False) *objects: zero or more objects to print. sep: how to separate objects. end: what to print at the end. file: where to print. flush: whether to forcibly flush the stream. Parameters vs Arguments # Parameters: variables in the function definition. Arguments: values passed to the function. Small pieace of code to demonstrate how to change the end parameter behavior # print(\u0026#34;Hello \u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;Bison!\u0026#34;) The expected output is Hello Bison!.\nNamed parameters vs Positional parameters # Named parameters: they are optional and can be passed in any order. Positional parameters: they are required and must be passed in the correct order. Escaping Characters # Escape character: backslash (). f-strings # f-string: formatted string literal. Example of code using f-strings # name = \u0026#34;Bison\u0026#34; print(f\u0026#34;Hello, {name}!\u0026#34;) The expected output is Hello, Bison!.\nString Methods # .strip(): remove whitespace.\n.capitalize(): capitalize the first letter.\n.title(): capitalize the first letter of each word.\n.lstrip(): remove whitespace from the left.\n.rstrip(): remove whitespace from the right.\nExample of code using .strip() and .title() # name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).strip().title() print(f\u0026#34;Hello, {name}!\u0026#34;) Style # Style: how code looks and is organized.\nPEP 8: Python Enhancement Proposal 8.\nsplit # .split(): split a string into a list. Example of code using .split() # names = input(\u0026#34;Enter names separated by commas: \u0026#34;).split(\u0026#34;, \u0026#34;) print(names) Expected output: ['Alice', 'Bob', 'Charlie'].\nIntegers and Operators # Integer: whole numbers.\nOperators: symbols that perform operations.\nTable of Operators # Operator Name Description + Addition Adds two numbers. - Subtraction Subtracts two numbers. * Multiplication Multiplies two numbers. / Division Divides two numbers. // Floor division Divides two numbers and rounds down. % Modulus Returns the remainder of the division. ** Exponentiation Raises a number to the power of another. Interactive mode # The interactive mode is a way to run Python code line by line.\nCalculator.py # x = input(\u0026#34;What\u0026#39;s x? \u0026#34;) y = input(\u0026#34;What\u0026#39;s y? \u0026#34;) z = x + y print(z) Type Conversion # Type conversion: converting one data type to another.\nint(): convert to integer.\nExample of code using int() # x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = int(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) print(x + y) Foating Point Values # Floating point values: decimal numbers.\nfloat(): convert to floating point.\nExample of code using float() # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) print(x + y) Rounding Numbers # round(): round a number to a specified number of decimal places. round(number[, ndigits]) Example of code using round() # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = round(x + y) print(z) Numeric Formatting # f-string: formatted string literal. Example of code using f-string to format a number # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = round(x + y) print(f\u0026#34;{z:,}\u0026#34;) Division # /: division. Example of code using / and // # x = float(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) y = float(input(\u0026#34;What\u0026#39;s y? \u0026#34;)) z = x / y print(f\u0026#34;{z:.2f}\u0026#34;) Defining Functions # def: define a function. Example of code defining a function # def main(): name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) hello(name) def hello(to=\u0026#34;Bison\u0026#34;): print(\u0026#34;Hello \u0026#34;, to) main() Scope # Scope: where a variable is accessible. Return Values # return: return a value from a function. Example of code using return # def main(): x = int(input(\u0026#34;What\u0026#39;s x? \u0026#34;)) print(\u0026#34;x squared is\u0026#34;, square(x)) def square(n): return pow(n, 2) main() ","date":"18 abril 2024","externalUrl":null,"permalink":"/projects/cs50-python/week_0/","section":"Projects","summary":"This week covers fundamental programming concepts including functions, data types, and debugging techniques, providing a foundational understanding for writing and troubleshooting code.","title":"Week 0: Functions, Variables","type":"projects"},{"content":"Hola, bienvenido a mi rincón del internet. Me gusta experimentar con cosas, un minuto, estoy probando una aplicación, y al siguiente, son las 3 de la mañana y estoy leyendo la documentación del kernel de Linux. Me gusta programar (sobre todo Python, Go y Bash, el stack SRE/Cloud), configurar servidores y proyectos curiosos como crear distribuciones de teclado personalizadas.\nPaso mucho tiempo en comunidades de código abierto, aprendiendo y compartiendo en el camino. Aquí encontrarás una mezcla de mis proyectos, historias de tecnología (victorias y derrotas) y tal vez algunas notas de clase. Antes lo ponía todo en GitHub, pero he decidido que es más fácil organizarlo todo aquí.\nNo planeo hacerme famoso ni millonario, sólo quiero compartir lo que sé y lo que estoy aprendiendo. No dudes en echar un vistazo.\nNota: Mis posts estarán escritos primero en inglés y luego traducidos al español, no los traduciré todos, así que la mayoría del contenido del blog solo estará disponible en inglés\n","date":"22 octubre 2024","externalUrl":null,"permalink":"/es/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"22 octubre 2024","externalUrl":null,"permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Administración de claves # Es administrar las llaves durante todo su tiempo de vida, desde que son creadas hasta que son destruidas, esto incluye el uso, almacenamiento, la asignación, la creación, y destrucción de estas.\nEsto nos permite mantener un ecosistema seguro, de manera que cada usuario puede tener acceso a diferentes permisos con una sola llave, como el funcionamiento de las antiguas llaves maestras.\nLas llaves pueden ser simétricas (una sola llave) para información que va a estar “en reposo” (es decir que no va a viajar a través de algún medio) como las propias llaves, o asimétricas (dos llaves) para información que va a estar “viajando” entre distintos medios.\nNormalmente se utiliza una mezcla de los dos sistemas criptográficos, usando un sistema asimétrico para enviar una llave simétrica, ya que la criptografía simétrica es más rápida, pero no puede transmitir por sí misma la llave de forma segura, por lo que se usa un sistema asimétrico para compartir la llave.\nLas llaves simétricas se encuentran cifradas de manera simétrica en un servidor KM (key manager), de manera que el usuario tiene que mandar su certificado (criptografía asimétrica) al servidor KM para compararlo con la autoridad certificadora, y le diga si es en realidad quien dice ser.\nUna vez hecho esto, el servidor envía su certificado al cliente para establecer una conexión, y luego el servidor KM descifra la llave simétrica (con otra llave simétrica) y se la manda al usuario a través de un canal TLS.\nLas llaves asimétricas conllevan un camino similar, solo que en vez de usar un canal TLS, utiliza la llave pública de los cifrados de cada uno (usuario y servidor) para compartir de manera segura una llave simétrica por medio de un canal (que pudiera no ser seguro), y a su vez la información encriptada con la llave simétrica.\nProceso de Autenticación y Cifrado Simétrico con Certificados # Proceso de Validación y Cifrado Asimétrico en un Servidor KM # Módulo de plataforma segura y usos de TPM # Es básicamente un cripto-procesador, un chip físico que puede venir como un aditamento, como es el caso de la fotografía, o puede estar incrustado en la placa base. Este chip se encarga de almacenar llaves y procesar sistemas criptográficos complejos, de manera que asiste al procesador (CPU), al mismo tiempo que es más seguro ya que únicamente puede conectarse con el procesador, evitando que algún hardware desconocido pueda copiar las llaves o modificar su funcionamiento.\nEntre las cosas que se pueden hacer, el TPM puede validar tu identidad utilizando llaves específicas del cripto-procesador (que no pueden ser modificadas) o incluso llaves de otras aplicaciones que son almacenadas dentro del mismo.\nTambién puede validar el sistema operativo, analizando componentes firmados, y si las firmas no coinciden, es porque probablemente el archivo ha sido modificado, lo que podría indicar algún tipo de infección (normalmente esto mismo evita el “secure boot”).\nDistintos usos para el chip TPM # DRM (Digital Rights Management) Cifrado de archivos y carpetas Correo electrónico seguro SSL VPN Contraseñas de uso único Administración de cuentas Two-Factor Authentication con las llaves del chip Componentes del chip # Generador de números aleatorios Generación de claves criptográficas Almacenamiento seguro de llaves Hashes Seguridad en Internet # Encontramos la criptografía en muchos lugares distintos, sobre todo en donde se ocupe algún tipo de autenticación, sobre todo cuando se usan contraseñas o certificados.\nExisten 3 métodos de autenticación:\nLa criptografía simétrica es para la información que no se encuentra en tráfico, por su velocidad y facilidad de manejo de llave.\nLa criptografía asimétrica es para la información que está en tránsito, normalmente se utiliza para el manejo de sesiones, y una vez establecida la conexión se usa criptografía simétrica para el envío de grandes volúmenes de información.\nEl problema de la seguridad en el manejo de contraseñas # Almacenamiento # Las contraseñas no deben ser guardadas en texto plano, por lo que surge la idea de almacenarlas como el hash de esta, de manera que, si un atacante las roba, no pueda revertirlas.\nFunciones Hash # Funciones de hash criptográficas ≠ Funciones de hash de contraseñas El principal problema es que las funciones de hash criptográficas no están diseñadas para las contraseñas. Tienden a ser muy rápidas, y en general esto sería bueno, si no fuera porque esto beneficia a un atacante que quiera hacer un ataque de fuerza bruta.\nReconocimiento # El primer paso a tomar es buscar si la contraseña ya se encuentra en alguna rainbow table en internet, o similar; en caso contrario, se procede a hacer el ataque de fuerza bruta.\nVelocidad # La velocidad juega un papel crucial, por lo que si el método de hashing es muy rápido (por decir 0.1 segundos), la contraseña puede ser rota en relativamente poco tiempo, por lo que buscamos mantener el proceso de hashing por encima de 0.1 segundos, preferentemente cerca de 1 segundo de velocidad.\nSal # La sal es un conjunto de letras generadas aleatoriamente para cada usuario que cambian el hash de salida, lo que dificulta al atacante (computacionalmente imposible) encontrar la contraseña del usuario generada en una rainbow table en internet.\nPimienta # Igual que la sal, la pimienta también cambia el hash final, pero suele estar dentro del código fuente. Esto es útil si por algún motivo la base de datos donde estamos guardando las contraseñas no es segura, o no podemos confiar en el tráfico desde la aplicación hasta la base de datos. Podemos agregar pimienta al código fuente como medida extra de seguridad.\nExtensión # PBKDF2 bcrypt scrypt Argon2 En estos algoritmos lo que se busca es iterar el uso de distintos hashes y sales para demorar el proceso de obtención del hash de la contraseña, y de esta manera fortalecer nuestra aplicación contra ataques de fuerza bruta.\nEl ataque POODLE (del inglés \u0026ldquo;Padding Oracle On Downgraded Legacy Encryption\u0026rdquo;) es relevante aquí. Para SSL 3.0 solo se necesitaban 256 solicitudes para revelar un byte de la comunicación. Este ataque aprovecha un mecanismo que reduce la seguridad con el fin de mantener interoperabilidad.\nPara TLS 1.0 a 1.2, el ataque se basa en fallas en el cifrado CBC.\nSSL Handshake # Se utiliza para establecer el método de encriptación que se va a mantener a lo largo de la comunicación y los datos de la sesión.\nContacto y establecimiento de capacidades: RSA Diffie-Hellman Autenticado Diffie-Hellman Anónimo Fortezza Intercambio de llaves y autenticación del servidor Intercambio de llaves y autenticación del cliente Finalización del protocolo (aquí se crean las llaves de sesión) SSL Récord # Se utiliza para transmitir información entre cliente y servidor.\nDatos del mensaje Fragmentación del mensaje Compresión de los fragmentos Agregado de un código de autenticación de mensaje Cifrado de los datos Agregado de un encabezado Envío del criptograma a través de TCP File Transfer Protocol # No contiene ninguna capa de seguridad.\nFile Transfer Protocol / SSL: # Es el mismo protocolo FTP pero sobre el protocolo SSL (actualmente TLS).\nSSH File Transfer Protocol # Es un protocolo creado desde cero, muy diferente a FTP, que funciona basado en SSH.\nSecure Copy Protocol # Se basa en:\nSSH FTP Comandos RCP ","date":"22 octubre 2024","externalUrl":null,"permalink":"/es/posts/crypt_exam_2/","section":"Posts","summary":"Este post es una re-escritura del documento de resumen dado por el profesor que incluye solo los temas del examen 2.","title":"Resumen del examen 2 de Criptografía","type":"posts"},{"content":"","date":"14 agosto 2024","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":" Topología # En packet tracer # En un entorno real # 1. Redundancia de red # En la topología propuesta, cada switch de salida de cada departamento tiene dos salidas, el switch principal (Main) y el switch de respaldo (Backup), por lo que tendríamos un STP con la raíz en el switch principal y la raíz secundaria en el switch de respaldo, de modo que si falla, simplemente podrían enviar sus paquetes a través del secundario sin ningún problema.\nDepartamento Número de puertos LAN del switch Ventas 12 Ingeniería 2.1 48 Ingeniería 2.2 12 Administración 24 Marketing 48 2. Configuración de cada Switch # Switch Configuración 1 - vlan 10 - name ventas - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 10 2.1 - vlan 20 - name ingeniería - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 20 2.2 - vlan 20 - name ingeniería - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 20 3 - vlan 30 - name administración - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 30 4 - vlan 40 - name marketing - (Inside each interface towards a computer) - switchport mode access - switchport access vlan 40 3. Router hacia el internet # En este caso, tenemos los switches \u0026ldquo;Main\u0026rdquo; y \u0026ldquo;Backup\u0026rdquo;, así que ellos realizarán el enrutamiento inter-VLAN, así que no necesitamos algo como un Router-On-A-Stick para hacer el enrutamiento de VLANs.\n4. EtherChannel # Es posible agregar un EtherChannel en cualquiera de los switches, un ejemplo práctico sería en el caso de que, por ejemplo, ingeniería crezca y ahora necesite mucho más ancho de banda o algo similar. Pondré un ejemplo genérico de la configuración para crear un EtherChannel entre dos switches:\nEn el switch1\ninterface range GigabitEthernet1/0/1 - 2 description enlace_hacia_switch2_Switch switchport mode trunk channel-group 1 mode active channel-protocol lacp En el switch2\ninterface range GigabitEthernet1/0/1 - 2 description enlace_hacia_switch1_Switch switchport mode trunk channel-group 1 mode active channel-protocol lacp Una vez configurado, EtherChannel agrupará los puertos seleccionados en ambos switches en un único “canal” lógico.\nEsto significa que el ancho de banda combinado de los enlaces físicos se utilizará para transportar tráfico entre el switch1 y el switch2. Si uno de los enlaces físicos falla, el tráfico se redirige automáticamente por el otro enlace sin intervención manual, manteniendo la conectividad y el rendimiento.\nImplementar EtherChannel mejorará significativamente el rendimiento de la red entre estos dos departamentos críticos y ayudará a manejar eficientemente grandes volúmenes de tráfico, asegurando además mayor disponibilidad y redundancia.\n5. Esquema de direccionamiento IP # Habrán 4 VLANs:\nVentas: 10 usuarios Administración: 20 usuarios Marketing: 35 usuarios Ingeniería: 50 usuarios Departamento Rango de IPs útiles Número de la VLAN Ventas 192.168.10.0 - 192.168.10.30 10 Ingeniería 192.168.10.128 - 192.168.10.190 20 Administración 192.168.10.32 - 192.168.10.62 30 Marketing 192.168.10.64 - 192.168.10.126 40 6. Gateway y máscaras de red las PCs de cada departamento # Departamento Gateway Máscara Ventas 192.168.10.1 255.255.255.224 Ingeniería 192.168.10.129 255.255.255.192 Administración 192.168.10.33 255.255.255.224 Marketing 192.168.10.65 255.255.255.192 7. Switches LAN, switch principal # La idea en esta topología es que el switch principal es el que se llama “Main”. El comando utilizado para verificar si el switch es el switch principal o no es:\n# show spanning-tree Una vez ejecutes el comando te dará un output así:\nSwitch#show spanning-tree VLAN0001 Spanning tree enabled protocol ieee Root ID Priority 32769 Address 0002.1770.0A10 This bridge is the root Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec Bridge ID Priority 32769 (priority 32768 sys-id-ext 1) Address 0002.1770.0A10 Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec Aging Time 20 Interface Role Sts Cost Prio.Nbr Type ----------- ---- --- --------- -------- ---- Fa0/2 Desg FWD 19 128.2 P2p Fa0/5 Desg FWD 19 128.5 P2p Fa0/1 Desg FWD 19 128.1 P2p En donde se puede ver, en la tercera línea de la sección \u0026ldquo;Root ID\u0026rdquo; que \u0026ldquo;This bridge is the root\u0026rdquo;, es decir, que este puente es la raiz.\n8. LAN switches, switch secundario # En este caso, como lo indica el nombre, la idea es que el router llamado “Backup” actúe como el secundario.\nEl comando que se utilizaría sería de la misma manera que el show spanning-tree, y en la leyenda que dice en la imagen anterior “Este puente es el root” dirá que es el secundario.\n9. STP separado por VLAN # Dada el tamaño de la red y la separación en varios departamentos con diferentes requisitos de conectividad, sería posible implementar PVST+. Su implementación podría mejorar la eficiencia operativa al permitir diferentes rutas raíz para diferentes VLAN, además de que es probable que aumente la estabilidad general de la red al identificar problemas potenciales de STP en VLAN individuales, evitando que un problema en una VLAN afecte a toda la red.\nImplementar PVST+ puede maximizar el uso de todos los enlaces disponibles y proporcionar una mejor experiencia al usuario al optimizar el tráfico de la red según las necesidades específicas de cada departamento.\n10. Comandos recomendados para la seguridad del STP # Dentro de cada interfaz conectada a una PC\nspanning-tree portfast: esto no es por seguridad, pero se recomienda encarecidamente utilizarlo en interfaces que van hacia dispositivos finales como PCs.\nspanning-tree bpduguard enable: este comando garantiza que si una interfaz se coloca en modo portfast para una PC, por ejemplo, y luego se conecta un dispositivo capaz de enviar paquetes BPDU, como un switch, este paquete BPDU no rompa el spanning-tree, desactivando la interfaz para lograr esto.\n","date":"25 mayo 2024","externalUrl":null,"permalink":"/es/posts/local-network-switching/","section":"Posts","summary":"Este fue mi proyecto final de la clase de conmutación de redes locales, es un documento acerca de la implementación de todos los temas vistos durante el semestre","title":"Conmutación de Redes Locales - Proyecto Final","type":"posts"},{"content":"","externalUrl":null,"permalink":"/es/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/es/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]